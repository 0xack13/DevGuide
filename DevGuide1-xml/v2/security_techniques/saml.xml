<!-- $Id: saml.xml,v 1.3 2004/03/04 22:32:32 awiesmann Exp $ -->

<!--
<author>
				<firstname>Abraham</firstname>
				<surname>Kang</surname>
				<email>abrahamkang@earthlink.net</email>
			</author>
			<author>
				<firstname>Andrew van der Stock</firstname>
				<surname>van der Stock</surname>
				<email>ajv@greebo.net</email>
			
			</author>
-->
<sect1>
	<title>SAML</title>
	<para>
		SAML stands for Security Assertions Markup Language. SAML provides an 
		interoperable XML schema for exchanging authentication, authorization, and user
		attribute related information. It allows different security infrastructures and applications 
		to shared authentication, authorization, and attribute related information. SAML is 
		important because it is the first time that all of the major vendors (IBM, Microsoft, 
		Oracle, Sun, BEA, SAP, etc.) have come together to support a single security standard.
	</para>
		
	<para>
		SAML is made up of three parts. The first part is the SAML element schema, which 
		represents authentication, authorization, and user attribute related information. The 
		second part is the XML schema that defines the SAML protocol in which the 
		authentication, authorization, and user attribute related information is requested and 
		supplied. The third part represents the SAML profiles and bindings. A SAML profile 
		describes the rules used to extract and embed SAML Assertions into a framework or 
		protocol. SAML Bindings explain how SAML messages work with standard messaging 
		or communication protocols. Although it is important to understand which elements go 
		where and what each element represents it is import to first get the big picture. Lets look 
		at the actual scenarios where SAML can be used.
	</para>
	<sect2>
		<title>SAML Usage Senarios</title>
		<para>
		In order to understand the usage scenarios we will need to go over some vocabulary. 
		Authorities are the sites or entities that hold user related information, or the sites the user 
		has authenticated to. There are three types of Authorities: Attribute, Authentication, and 
		Authorization.
		</para>
		<para>
		An Attribute authority could provide credit limit information.  
		</para>
		<para>
		An Authentication authority would provide information on when a user was authenticated and
		by what means. 
		</para>
		<para>
		An Authorization authority could vouch for different access rights that an 
		authenticated user possesses.
		</para>
	</sect2>
	<sect2>
		<title>SSO Pull Scenario</title>
		<para>
		In this scenario the user has already authenticated to a Web site (Attribute and 
		Authentication Authority) and is trying to access a partner site (Policy Decision Point and 
		Policy Enforcement Point). All of the links to the partner site reference an inter-site 
		transfer URL. When the user clicks the URL to the partner site, the source site receives 
		the request (through the inter-site URL) and places an artifact in the HTTP 302 response 
		or places an assertion in the HTML page returned. The user is then redirected to the 
		destination site's artifact or assertion consumer URL. The destination verifies the artifact 
		or assertion and returns the requested HTML resource. 
		</para>
	</sect2>
		
	<sect2>
		<title>Distributed Transaction Scenario</title>
		<para>
		Basically a SOAP client authenticates to a SOAP service that participates within a set of 
		loosely coupled B2B Web Service Supply Chain Services. A supplier or buyer has to only 
		setup their contractual agreements once and can seamlessly access all other member Web 
		Service interfaces to buy and sell products. Within the supply chain consortium there is a 
		centralized Authentication, Authorization, and Attribute Authority. All members initially 
		login to this service and receive the associated Assertions to interact with other supply 
		chain partners. Whenever a user wants to create a transaction with another partner they 
		attach their assertion to the transaction request. The receiver then confirms the assertion 
		with the centralized authority or verifies and accepts the assertion if the assertion is 
		signed. After confirming the request a response is sent to the message initiator to confirm 
		or deny the transaction.
		</para>
			
		<para>
		A different spin of this is where the user authenticates to a site, which can make orders on 
		behalf of the logged in user at another site. When a user needs to initiate a transaction at 
		the partner site, the appropriate assertions are generated and sent to the other site on 
		behalf of the user. The assertions are used to validate the user credentials, credit limits, 
		and commit the transaction.
		</para>
			
		<para>
		Now that you understand where SAML can be used, lets look 
		at the core SAML elements that define the authentication, authorization, and user 
		attribute related information.
		</para>
	</sect2>
	<sect2>
		<title>SAML Assertions</title>
			
		<para>
		The Assertion element represents the core container element within SAML. The 
		Assertion element is the main element because it represents a statement of proof about a 
		Subject. Assertions hold any number of three different "Statement" types. The 
		"Statement" types (Authentication, Attribute, and AuthorizationDecision) correspond 
		with the three different types of information that can be conveyed between an 
		"Asserting" and "Relying" (RP) party. A "Relying" party requests authentication, 
		authorization, and attribute related information from an "Asserting" party (AP). A 
		"Relying" party relies on the assertions provided by the "Asserting" party to make 
		authentication, authorization, and attribute related decisions. "Asserting" parties are also 
		referred to as Authorities. The different types of information that can be passed between 
		a RP and AP also categorize authorities. Authorities can be any combination of 
		Authentication, Authorization, and Attribute Authorities. 
		</para>
			
		<para>
		A SAML Assertion is made up of required and optional elements and attributes. The 
		mandatory attributes are:  
		</para>
			
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
				AssertionID --  The AssertionID must be a globally unique identifier 
				with less than 2^-128 (2^-160 recommended) probability of creating 
				duplicates for different Assertions.
				</para>
			</listitem>
				
			<listitem>
				<para>MajorVersion  -- "1" for SAML 1.0</para>
			</listitem>
				
			<listitem>
				<para>MinorVersion  -- "0" for SAML 1.0</para>
			</listitem>
				
			<listitem>
				<para>Issuer --  String that represents the issuer of the assertion 
				(authority). This can be any string that is known to identify the 
				Issuer of the Assertion.</para>
			</listitem>
				
			<listitem>
				<para>IssueInstant  --  The date and time in UTC format when the 
				assertion was created. 
				UTC is sometimes called GMT. All time is relative to UTC (or GMT) and the format 
				is "YYYY-MM-DDTHH:MM:SSZ". An example is "2003-01-04T14:36:04Z". T is 
				the date time separator. Z stands for "Zulu" or GMT time zone.
				</para>
			</listitem>
		</itemizedlist>
			
		<para>
		The optional elements are:
	</para>
			
		<orderedlist>
			<listitem>
				<para>Conditions:</para>
					
				<para>
				Give additional restrictions on determining the validity of an assertion. The attributes 
				of the saml:Conditions element define the validity period using NotBefore and 
				NotOnOrAfter attribute. If there is a saml:Conditions element with no sub elements 
				or attributes then the assertion is valid without further investigation. If the 
				saml:Conditions element has nested saml:Condition elements then the validity of the 
				assertion is based on the folowing rules:
				</para>
				<para>
					<orderedlist numeration="loweralpha">
						<listitem>
							<para>If any saml:Condition or saml:AudienceRestrictionCondition element within the 
			saml:Conditions element is invalid or if the current dateTime falls outside of the 
			NotBefore or NotOnOrAfter attributes then the assertion is invalid.</para>
						</listitem>
							
						<listitem>
							<para>If any saml:Condition or saml:AudienceRestrictionCondition element within the 
			saml:Conditions element cannot be verified as valid or invalid then the Assertion 
			is Indeterminate.</para>
						</listitem>
							
						<listitem>
							<para>Only when all saml:Condition and/or saml:AudienceRestrictionCondition 
			elements nested within the saml:Conditions element are valid is the Assertion 
			valid.</para>
						</listitem>
					</orderedlist>
				</para>
			</listitem>
				
			<listitem>
				<para>Advice:</para>
				<para>Holds additional information that the issuer wishes to provide in the form of any 
				number of saml:AssertionIDReference, saml:Assertion, and/or any valid and well 
				formed XML element that's namespace resides outside the target namespace (
<![CDATA[
<any namespace="##other" processContents="lax"/>
]]>
).
</para>
			</listitem>
				
			<listitem>
				<para>Statement Type</para>
				<para>Any mix of one or more saml:Statement types (saml:Statement, 
saml:SubjectStatement, saml:AuthenticationStatement, 
saml:AuthorizationDecisionStatement, saml:AttributeStatement).</para>
				<para>
					<orderedlist numeration="loweralpha">
						<listitem>
							<para>
							The saml:Statement' type serves as a base type to extend 
							from when you want to create your Statement types. The 
							saml:Statement element does not define any 
							nested elements or attributes and therefore have little practical 
							value on its own. Here is the XML schema that describes this 
							element:
							</para>
							<para>
								<screen><![CDATA[
<element name="Statement" type="saml:StatementAbstractType"/>
<complexType name="StatementAbstractType" abstract="true"/>]]></screen>
							</para>
						</listitem>
							
						<listitem>
							<para>
							The saml:SubjectStatement's type serves as a base type to 
							extend from when you want to create your SubjectStatement types. 
							The only difference between a saml:Statement and 
							saml:SubjectStatement is that the saml:SubjectStatement has 
							a nested saml:Subject element. 
							Here is the XML Schema that describes this element:
							</para>
							<para>
								<screen><![CDATA[
<element name="SubjectStatement"    
     type="saml:SubjectStatementAbstractType" /> 
<complexType name="SubjectStatementAbstractType" abstract="true"> 
<complexContent> 
<extension base="saml:StatementAbstractType"> 
<sequence> 
<element ref="saml:Subject" /> 
</sequence> 
</extension> 
</complexContent>
</complexType>
]]></screen>
							</para>
						</listitem>
							
						<listitem>
							<para>The saml:AuthenticationStatement can be extended but it is typically used as-is. 
A saml:AuthenticationStatement asserts that a subject was authenticated using a 
specific method (Kerberos, password, X509 Cert, etc.) at a specific time. 
Here is a sample assertion with a saml:AuthenticationStatement:</para>
							<para>
								<screen><![CDATA[
<saml:Assertion ...>
<saml:AuthenticationStatement
   AuthenticationMethod="urn:oasis:names:tc:SAML:1.0:am:password"
   AuthenticationInstant="2003-12-03T10:02:00Z">
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" NameQualifier="smithco.com">
joeuser@smithco.com
</saml:NameIdentifier>
</saml:Subject>
</saml:AuthenticationStatement>
</saml:Assertion>]]>
</screen>
							</para>
						</listitem>
							
						<listitem>
							<para>The saml:AttributeStatement can also be extended but it is typically used as-is. 
The saml:AttributeStatement asserts that a subject has a set of attributes 
(A,B,C,etc.) with associated values ("a","b","c",etc.). Here is an example:</para>
							<para>
								<screen> <![CDATA[
<saml:Assertion ...>
<saml:AttributeStatement>
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" 
NameQualifer="smithco.com">joeuser@smithco.com
   </saml:NameIdentifier>
</saml:Subject>
<saml:Attribute AttributeName="Department"
AttributeNamespace="http://smithco.com">
   <saml:AttributeValue>
   Engineering
   </saml:AttributeValue>
</saml:Attribute>
<saml:Attribute
AttributeName="CreditLimit"
AttributeNamespace="http://smithco.com">
   <saml:AttributeValue>
      500.00
   </saml:AttributeValue>
</saml:Attribute>
</saml:AttributeStatement>
</saml:Assertion>]]></screen>
							</para>
						</listitem>
							
						<listitem>
							<para>The saml:AuthorizationDecisionStatement can also be extended but is typically 
used as-is. The saml:AuthorizationDecisionStatement asserts that a subject should 
be granted or denied access to a specific resource. Here is an example:</para>
							<para>
								<screen><![CDATA[
<saml:Assertion ...>
<saml:AuthorizationDecisionStatement
Decision="Permit"
Resource="http://jonesco.com/rpt_12345.htm">
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" 
NameQualifer="smithco.com">joeuser@smithco.com 
</saml:NameIdentifier>
</saml:Subject>
<saml:Actions
<saml:Action Namespace= 
"urn:oasis:names:tc:SAML:1.0:action:rwedc">Read
</saml:Action>
</saml:Actions>
</saml:AuthorizationStatement>
</saml:Assertion>]]>
</screen>
							</para>
						</listitem>
						
					</orderedlist>
				</para>
			</listitem>
		</orderedlist>
	</sect2>
	<sect2>
		<title>SAML Protocol</title>
		<para>
		The SAML Protocol is pretty simple. A relying party makes a request and an asserting 
		party (Authority) provides the response. The Relying Party sends a samlp:Request to the 
		Asserting Party. If successful, the Asserting Party includes an Assertion in the samlp:Response.
		If unsuccessful, the Asserting Party does NOT return an Assertion and returns the status instead.
		</para>
			
		<para>The samlp:Request</para>
			
		<para>The samlp:Request element is extended from the samlp:RequestAbstractType. XML 
		extension allows a target XML element which gets its type from a parent base type to add 
		additional attributes or elements to a defined child type which extends the parent base 
		type as long as the instance of the target XML element specifies the child type as a 
		xsi:type attribute (That was a mouthful.  Look at the "Extending SAML Elements" section 
		for an example). The samlp:RequestAbstractType looks like the following:
		</para>
		<para>
			<screen><![CDATA[
<complexType name="RequestAbstractType" abstract="true"> 
<sequence> 
<element ref="samlp:RespondWith" minOccurs="0" maxOccurs="unbounded"/> 
<element ref = "ds:Signature" minOccurs="0"/> 
</sequence>
<attribute name="RequestID" type="saml:IDType" use="required"/> 
<attribute name="MajorVersion" type="integer" use="required"/> 
<attribute name="MinorVersion" type="integer" use="required"/> 
<attribute name="IssueInstant" type="dateTime" use="required"/> 
</complexType>]]></screen>
		</para>
			
		<para>
		The samlp:Request inherits four mandatory attributes and two optional elements 
		from the RequestAbstractType. The samlp:Request is defined as follows:
		</para>
			
		<para>
			<screen><![CDATA[
<element name="Request" type="samlp:RequestType"/> 
<complexType name="RequestType"> 
<complexContent> 
<extension base="samlp:RequestAbstractType"> 
<choice> 
<element ref="samlp:Query"/> 
<element ref="samlp:SubjectQuery"/> 
<element ref="samlp:AuthenticationQuery"/> 
<element ref="samlp:AttributeQuery"/> 
<element ref="samlp:AuthorizationDecisionQuery"/> 
<element ref="saml:AssertionIDReference" maxOccurs="unbounded"/> 
<element ref="samlp:AssertionArtifact" maxOccurs="unbounded"/> 
</choice> 
</extension> 
</complexContent> 
</complexType>]]></screen>
		</para>
			
		<para>
		So the samlp:Request has all of the attributes and elements of the 
		samlp:RequestAbstractType and only adds a choice of the following elements: 
		samlp:Query, samlp:SubjectQuery, samlp:AuthenticationQuery, samlp:AttributeQuery, 
		samlp:AuthorizationDecisionQuery, saml:AssertionIDReference (one or more) or 
		samlp:AssertionArtifact (one or more). Lets look at the attributes and sub-elements in 
		more detail.
		</para>
			
		<para>The samlp:Request contains four mandatory attributes:</para>
			
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
				RequestID -- The RequestID must be a globally unique 
				identifier with less than 2^-128 (2^-160 recommended) probability 
				of creating duplicates for different Requests.
				</para>
			</listitem>
			<listitem>
				<para>MajorVersion  -- "1" for SAML 1.0</para>
			</listitem>
			<listitem>
				<para>MinorVersion  -- "0" for SAML 1.0</para>
			</listitem>
			<listitem>
				<para>
				IssueInstant  --  The date and time in UTC format when the request 
				was initiated. 
				UTC is sometimes called GMT. All time is relative to UTC (or GMT) and the format 
				is "YYYY-MM-DDTHH:MM:SSZ". An example is "2003-01-04T14:36:04Z". T is 
				the date time separator. Z stands for "Zulu" or GMT time zone.
				</para>
			</listitem>
		</itemizedlist>
			
		<para>The samlp:Request also has optional sub-elements:</para>
			
		<orderedlist>
			<listitem>
				<para>samlp:RespondWith</para>
				<para>
				This allows you specify what type of Statement you are 
				requesting. The only requirement is that you specify QNames. A QName is an XML 
				element that includes its namespace prefix. The format of a QName is 
				prefix:elementName. If you do not specify anything you will get all Statements that 
				are associated with the subject that you are verifying. You can specify one or more of 
				these. Here is an example:
				</para>
				<para>
					<screen><![CDATA[
<RespondWith>saml:AttributeStatement</RespondWith>
<RespondWith>saml:AuthenticationStatement</RespondWith>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>ds:Signature</para>
				<para>This element allows you to sign the request to verify that the request 
				was generated by a specific signer. Please refer to the chapter on XML Signature to 
				get the details of this element.
				</para>
			</listitem>
		</orderedlist>
		<para>
		Finally the samlp:Request has to have a Query or Assertion pointer associated with 
		it. The Query has to determine what type of Statement to return so it mimics the saml:Statement 
		element's hierarchy.  The Assertion pointer is a reference to an AssertionID or Artifact.  
		Here are the seven different Query types:
		</para>
			
		<orderedlist>
			<listitem>
				<para>samlp:Query</para>
				<para>
				The Query element has a similar structure to the saml:Statement. The 
				Query element is based on an abstract type, is empty, and is primarily used as an 
				XML extension point. Here is XML Schema definition:
				</para>
				<para>
					<screen><![CDATA[
<element name="Query" type="samlp:QueryAbstractType"/> 
<complexType name="QueryAbstractType" abstract="true"/>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>samlp:SubjectQuery</para>
				<para>The SubjectQuery element has a similar structure to the 
saml:SubjectStatement. The SubjectQuery's type serves as a base type to extend from 
when you want to create your SubjectQuery types. The only difference between a 
samlp:Query and samlp:SubjectQuery is the samlp:SubjectQuery has a nested 
saml:Subject element. Here is XML Schema definition:</para>
				<para>
					<screen><![CDATA[ 
<element name="SubjectQuery" type="samlp:SubjectQueryAbstractType"/>
<complexType name="SubjectQueryAbstractType" abstract="true"> 
<complexContent> 
<extension base="samlp:QueryAbstractType"> 
<sequence> 
<element ref="saml:Subject"/> 
</sequence> 
</extension> 
</complexContent> 
</complexType>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>samlp:AuthenticationQuery</para>
				<para>The AuthenticationQuery can 
be extended but it is typically used as-is. A samlp:AuthenticationQuery asks for 
all the Authentication Assertions related to a specific subject that define 
previous authentication acts between the specified subject and the 
Authentication authority. It looks just like a samlp:SubjectQuery but adds an 
optional samlp:AuthenticationMethod element that is of type anyURI. The 
samlp:AuthenticationMethod element serves as a filter and will only retrieve 
saml:AuthenticationStatements with the noted AuthenticationMethod. The 
authentcation method can be one of the following values:</para>
				<para>
					<screen><![CDATA[ 
 urn:oasis:names:tc:SAML:1.0:am:password          (password)
 urn:ietf:rfc:1510                                (kerberos)
 urn:ietf:rfc:2945                                (Secure Remote Password)
 urn:oasis:names:tc:SAML:1.0:am:HardwareToken     (Hardware token)
 urn:ietf:rfc:2246                                (SSL/TLS Cert Authentication)
 urn:oasis:names:tc:SAML:1.0:am:X509-PKI          (X509 Public Key)
 urn:oasis:names:tc:SAML:1.0:am:PGP               (PGP Public Key)
 urn:oasis:names:tc:SAML:1.0:am:SPKI              (SPKI Public Key)
 urn:oasis:names:tc:SAML:1.0:am:XKMS              (XKMS Public Key)
 urn:ietf:rfc:3075                                (XML Digital Signature)
 urn:oasis:names:tc:SAML:1.0:am:unspecified       (unspecified)]]></screen>
				</para>
				<para>Here is XML Schema definition:</para>
				<para>
					<screen><![CDATA[ 
<element name="AuthenticationQuery" type="samlp:AuthenticationQueryType"/> 
<complexType name="AuthenticationQueryType"> 
<complexContent> 
<extension base="samlp:SubjectQueryAbstractType"> 
<attribute name="AuthenticationMethod" type="anyURI"/> 
</extension> 
</complexContent> 
</complexType>]]></screen>
				</para>
				<para>Here is an example of an authentication query:</para>
				<para>
					<screen><![CDATA[ 
<samlp:Request MajorVersion="1" MinorVersion="0"
RequestID="128.14.234.20.12345678"
IssueInstant="2001-12-03T10:02:00Z">
<samlp:RespondWith>saml:AuthenticationStatement
</samlp:RespondWith>
<ds:Signature>...</ds:Signature> 
<samlp:AuthenticationQuery>
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" 
NameQualifier="smithco.com">
joeuser@smithco.com
</saml:NameIdentifier>
</saml:Subject>
</samlp:AuthenticationQuery>
</samlp:Request>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>samlp:AttributeQuery</para>
				<para>The AttributeQuery can be extended but it is typically used 
as-is. A saml:AttributeQuery asks for the attributes related to a specific subject. It 
looks just like a samlp:SubjectQuery but adds an optional saml:AttributeDesignator 
element and an optional Resource attribute. The saml:AttributeDesignator acts as a 
filter in the same way the AuthenticationMethod worked. If no AttributeDesignator 
is mentioned then all attributes related to the subject are returned. The resource 
attribute allows you to tell the Attribute Authority that the attribute request is being 
made in response to a specific authorization decision relating to a resource. Here is 
the XML Schema:</para>
				<para>
					<screen><![CDATA[ 
<element name="AttributeQuery" type="samlp:AttributeQueryType"/> 
<complexType name="AttributeQueryType"> 
<complexContent> 
<extension base="samlp:SubjectQueryAbstractType"> 
<sequence> 
<element ref="saml:AttributeDesignator" 
minOccurs="0" maxOccurs="unbounded"/> 
</sequence>
<attribute name="Resource" type="anyURI reference" 
use="optional"/> 
</extension> 
</complexContent> 
</complexType>]]></screen>
				</para>
				<para>Just as a reminder here is the definition of saml:AttributeDesignator:</para>
				<para>
					<screen><![CDATA[ 
<element name="AttributeDesignator" type="saml:AttributeDesignatorType"/> 
<complexType name="AttributeDesignatorType"> 
<attribute name="AttributeName" type="string" use="required"/> 
<attribute name="AttributeNamespace" type="anyURI" use="required"/> 
</complexType> ]]></screen>
				</para>
					
				<para>Here is an example of an AttributeQuery:</para>
				<para>
					<screen><![CDATA[ 
<samlp:Request...>
<samlp:AttributeQuery>
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" NameQualifier="smithco.com"> 
joeuser@smithco.com
</saml:NameIdentifier>
</saml:Subject>
<saml:AttributeDesignator AttributeName="PaidStatus" 
AttributeNamespace="http://smithco.com"/>
</samlp:AttributeQuery>
</samlp:Request>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>samlp:AuthorizationDecisionQuery</para>
				<para>The AuthorizationDecisionQuery can be 
extended but it is typically used as-is. A saml:AuthorizationDecisionQuery asks if a 
subject can execute certain actions on a specific resource given some evidence. It 
looks just like a samlp:SubjectQuery but adds a required saml:Action element, an 
optional saml:Evidence element, and an optional Resource attribute. The 
saml:Action defines what the subject wants to do. The saml:Evidence defines the 
additional Assertions that the subject is providing to the Authorization Authority to 
help it make its decision. The resource is an URI which defines the object that the 
authorization query is related to. Lets take a closer look at each of these elements.
The saml:Action is defined as follows:</para>
				<para>
					<screen><![CDATA[ 
<element name="Action" type="saml:ActionType"/> 
<complexType name="ActionType"> 
<simpleContent>
<extension base="string"> 
<attribute name="Namespace" type="anyURI"/> 
</extension> 
</simpleContent> 
</complexType>]]></screen>
				</para>
					
				<para>SAML defines a set of Action Namespaces and their associated values. They are as 
follows:</para>
					
				<para>
					<screen><![CDATA[ 
Read/Write/Execute/Delete/Control
Namespace:              urn:oasis:names:tc:SAML:1.0: action:rwedc
Possible Values:        Read Write Execute Delete Control
Comments:               The values describe what you can do with the resource.

Read/Write/Execute/Delete/Control with Negation
Namespace:              urn:oasis:names:tc:SAML:1.0:action:rwedc-negation
Possible Values:        Read Write Execute Delete Control ~Read ~Write ~Execute 
                        ~Delete ~Control
Comments:               The values describe what you can do with the resource.

Get/Head/Put/Post
Namespace:              urn:oasis:names:tc:SAML:1.0: action:ghpp
Possible Values:        GET HEAD PUT POST
Comments:               The values describe common HTTP operations that you could 
                        execute on a URL resource.

UNIX File Permissions
Namespace:              urn:oasis:names:tc:SAML:1.0:action:unix
Possible Values:        4 digit number, XXXX, where X represents a decimal number
Comments:               The 4 digits represent extended user group world permissions. 
                        So if extended is set to +2, sgid is set, if extended is set 
                        to +4 suid is set. The rest of the digits follow the 
                        standard rwx Unix values. 7 is read, write, and execute. 
                        5 is read and execute, etc.]]></screen>
				</para>
					
				<para>Here is an example AuthorizationDecisionQuery:</para>
				<para>
					<screen><![CDATA[ 
<samlp:Request ...>
<samlp:AuthorizationDecisionQuery 
Resource="http://jonesco.com/rpt_12345.htm">
<saml:Subject>
<saml:NameIdentifier Format="#emailAddress" NameQualifier="smithco.com"> 
joeuser@smithco.com
</saml:NameIdentifier>
</saml:Subject>
<saml:Actions Namespace="http://...">
<saml:Action Namespace="urn:oasis:names:tc:SAML:1.0:action:rwedc">Read
</saml:Action>
</saml:Actions>
<saml:Evidence>
<saml:Assertion>...</saml:Assertion>
</saml:Evidence>
</samlp:AuthorizationDecisionQuery>
</samlp:Request>]]></screen>
				</para>
			</listitem>
		</orderedlist>
			
		<para>The last two elements define alternate methods of fetching assertions by presenting an 
artifact (samlp:AssertionArtifact) or by presenting an AssertionID 
(saml:AssertionIDReference). You could have one or more of the following elements.</para>
		<orderedlist>
			<listitem>
				<para>saml:AssertionIDReference</para>
				<para>The saml:AssertionIDReference is of type 
IDType and basically points to an assertion that it is requesting. Here is an example:</para>
				<para>
					<screen><![CDATA[ 
<saml:AssertionIDReference>128.14.234.20.12345678</saml:AssertionIDReference>]]></screen>
				</para>
			</listitem>
				
			<listitem>
				<para>samlp:AssertionArtifact</para>
				<para>The samlp:AssertionArtifact is based on the xsi:type 
String. It holds an 8 byte Base 64 encoded string that indirectly points to an Assertion. Here is an example:</para>
				<para>
					<screen><![CDATA[ 
<saml:AssertionArtifact >128.14.234.20.12345678</saml:AssertionArtifact >]]></screen>
				</para>
			</listitem>
		</orderedlist>
			
		<para>Once the request is received, the Authority has to send a response. Coincidentally, the 
element returned is samlp:Response.</para>
	</sect2>
	<sect2>
		<title>The samlp:Response</title>
		<para>The samlp:Response contains a set of assertions ( if successful) or status code (when 
things go wrong). The samlp:Response, like the samlp:Request, extends an abstract type 
samlp:ResponseAbstractType. A samlp:Response can be signed to verify the sending 
party to the relying party. The samlp:ResonseAbstractType looks like the following:</para>
			
		<para>
			<screen><![CDATA[
<complexType name="ResponseAbstractType" abstract="true"> 
<sequence>
<element ref = "ds:Signature" minOccurs="0"/> 
</sequence> 
<attribute name="ResponseID" type="saml:IDType" use="required"/> 
<attribute name="InResponseTo" type="saml:IDReferenceType" use="optional"/> 
<attribute name="MajorVersion" type="integer" use="required"/> 
<attribute name="MinorVersion" type="integer" use="required"/> 
<attribute name="IssueInstant" type="dateTime" use="required"/> 
<attribute name="Recipient" type="anyURI" use="optional"/> 
</complexType>]]></screen>
		</para>
			
		<para>The ResponseAbstractType defines an optional ds:Signature element which allows the 
Response to be signed. There are 4 required attributes and 2 optional attributes.</para>
			
		<para>The 4 required attributes of the samlp:ResponseAbstractType are:
</para>
			
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>ResponseID -- The ResponseID must be a globally unique identifier with less than 
2^-128 (2^-160 recommended) probability of creating duplicates for different Requests.</para>
			</listitem>
			<listitem>
				<para>MajorVersion  -- "1" for SAML 1.0</para>
			</listitem>
			<listitem>
				<para>MinorVersion  -- "0" for SAML 1.0</para>
			</listitem>
			<listitem>
				<para>IssueInstant  --  The date and time in UTC format when the assertion was created. 
		UTC is sometimes called GMT. All time is relative to UTC (or GMT) and the format 
		is "YYYY-MM-DDTHH:MM:SSZ". An example is "2003-01-04T14:36:04Z". T is 
		the date time separator. Z stands for "Zulu" or GMT time zone.</para>
			</listitem>
		</itemizedlist>
		<para>The 2 required attributes of the samlp:ResponseAbstractType are:</para>
			
		<orderedlist>
			<listitem>
				<para>InResponseTo</para>
				<para>This holds the RequestID of the samlp:Request that generated this 
samlp:Response.</para>
			</listitem>
			<listitem>
				<para>Recipient</para>
				<para>A URI that represents a recipient or a resource managed by a recipient.  This value if present must be verified by the recipient.
</para>
			</listitem>
		</orderedlist>
		<para>
The samlp:Request extends the samlp:ResponseAbstractType by adding a required 
samlp:Status element and optional saml:Assertion element. If the Status is "success" the 
response includes an Assertion. If the Status is "failure" then the Response will NOT 
contain an assertion. Here is XML schema definition for samlp:Response:
</para>
			
		<para>
			<screen>
<![CDATA[
<element name="Response" type="samlp:ResponseType"/> 
<complexType name="ResponseType"> 
<complexContent> 
<extension base="samlp:ResponseAbstractType"> 
<sequence> 
<element ref="samlp:Status"/> 
<element ref="saml:Assertion" minOccurs="0" maxOccurs="unbounded"/> 
</sequence> 
</extension> 
</complexContent> 
</complexType>]]></screen>
		</para>
			
		<para>
You should be familiar with saml:Assertion. The samlp:Status probably needs more 
explaining. The samlp:Status describes the result of the samlp:Request. The 
samlp:Status has the following XML Schema definition:
</para>
			
		<para>
			<screen>
<![CDATA[
<element name="Status" type="samlp:StatusType"/> 
<complexType name="StatusType"> 
<sequence> 
<element ref="samlp:StatusCode"/> 
<element ref="samlp:StatusMessage" minOccurs="0" maxOccurs="1"/> 
<element ref="samlp:StatusDetail" minOccurs="0"/> 
</sequence> 
</complexType>]]></screen>
		</para>
			
		<para>
		The samlp:Status has a complex structure where its sub-element, samlp:StatusCode, can 
		have nested samlp:StatusCode elements. Each of the samlp:StatusCode elements has a 
		single required Value attribute. Here is the XML Schema that describes the 
		samlp:StatusCode element:
	</para>
			
		<para>
			<screen>
<![CDATA[
<element name="StatusCode" type="samlp:StatusCodeType"/> 
<complexType name="StatusCodeType"> 
<sequence> 
<element ref="samlp:StatusCode" minOccurs="0"/> 
</sequence> 
<attribute name="Value" type="QName" use="required"/> 
</complexType>]]></screen>
		</para>
		<para>
The Value attribute of the top level samlp:StatusCode has to have one of the following values:
</para>
			
		<para>
			<screen>
Success -- The request succeeded. 
VersionMismatch -- The version was incorrect. 
Requester -- There was an error at the requester.
Responder -- There was an error at the responder.</screen>
		</para>
			
		<para> 
		The second-level status codes can be one of the following:
	</para>
			
		<para>
			<screen>
RequestVersionTooHigh -- The request's version is not supported by the responder 
                         because it is too high.
RequestVersionTooLow --  The request's version is not supported by the responder 
                         because it is too low.
RequestVersionDeprecated -- The responder does not accept the version of the 
                            protocol specified. 
TooManyResponses -- The response could only return a subset of all the value elements.
RequestDenied -- The responder has elected not to respond due to an insecure environment 
                 or protocol resonse. 
ResourceNotRecognized -- The responder does not acknowledge the resource provided 
                         because it is invalid or unrecognized.</screen>
		</para>
			
		<para>
		All of the samlp:Status values above are Qnames (qualified names) in the 
		urn:oasis:names:tc:SAML:1.0:protocol namespace. If you wanted to create your own 
		samlp:Status values, they have to be in their own namespace and be fully qualified.
		Here is an example:
	</para>
			
		<para>
			<screen><![CDATA[
<StatusCode Value="myPrefix:TheServerIsOverwhelmed">
<StatusCode Value="myPrefix:TooManyConcurrentSSLRequests"/>
</StatusCode>]]></screen>
		</para>
			
		<para>
		The samlp:StatusMessage serves as a generalized error description corresponding to the 
		state of the top level samlp:Status. The samlp:StatusDetail allows you to provide any 
		well formed XML that can be processed further by the Relying party.
	</para>
			
		<para>
		Here is an example of a samlp:Response:
	</para>
			
		<para>
			<screen><![CDATA[
<samlp:Response MajorVersion="1" MinorVersion="0" 
   ResponseID="128.14.234.20.90123456" InResponseTo="128.14.234.20.12345678"
   IssueInstant="2001-12-03T10:02:00Z" Recipient="...URI..."
   xmlns:samlp="urn:oasis:names:tc:SAML:1.0:protocol" > 
<samlp:Status>
<samlp:StatusCode Value="samlp:Success" />
<samlp:StatusMessage>Some message</samlp:StatusMessage>
</samlp:Status>
<saml:Assertion MajorVersion="1" MinorVersion="0"    
   AssertionID="128.9.167.32.12345678" Issuer="smithco.com">
<saml:Conditions NotBefore="2001-12-03T10:00:00Z"
   NotAfter="2001-12-03T10:05:00Z" />
<saml:AuthenticationStatement ...>
</saml:AuthenticationStatement>
</saml:Assertion>
</samlp:Response>]]></screen>
		</para>
	</sect2>
		
	<sect2>
		<title>Bindings and Profiles</title>
			
		<para>
		A binding defines how SAML Requests and Responses are mapped into a transport 
		protocol for transport between a relying and asserting party. A profile defines how a 
		framework or protocol can use SAML to make assertions about components or parts of 
		that protocol or framework. SAML over SOAP is the only binding defined in the SAML 
		spec. Although SOAP can be transferred over many transports, HTTP is the only 
		required binding for SOAP. So SAML over SOAP over HTTP is a baseline. 
	</para>
			
		<para>
		SOAP is a XML based RPC (Remote Procedure Call) protocol. It is made up of three 
		major XML elements: a root level Envelope element, a Header element that is a sub-
		element of Envelope, and a Body element that follows the Header element and is a sub-
		element of Envelope. Here is an example of how a SAML Request is passed over SOAP:
	</para>
			
		<para>
			<screen><![CDATA[
POST /SamlService HTTP/1.1 Host: www.example.com 
Content-Type: text/xml 
SOAPAction: http://www.oasis-open.org/committees/security 
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"> 
<SOAP-ENV:Body> 
<samlp:Request xmlns:samlp:="..." xmlns:saml="..." xmlns:ds="..."> 
<ds:Signature> ... </ds:Signature> 
<samlp:AuthenticationQuery> 
   ...
</samlp:AuthenticationQuery> 
</samlp:Request> 
</SOAP-ENV:Body> 
</SOAP-ENV:Envelope>]]></screen>
		</para>
			
		<para>
		Here is how the SAML Response is returned within a SOAP Envelope:
	</para>
			
		<para>
			<screen><![CDATA[
HTTP/1.1 200 OK Content-Type: text/xml 
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"> 
<SOAP-ENV:Body> 
<samlp:Response xmlns:samlp="..." xmlns:saml="..." xmlns:ds="..."> 
<Status> 
<StatusCodevalue="samlp:Success"/>
</Status> 
<ds:Signature> ... </ds:Signature> 
<saml:Assertion> 
<saml:AuthenticationStatement> 
... 
</saml:AuthenticationStatement> 
</saml:Assertion> 
</samlp:Response> 
</SOAP-Env:Body> 
</SOAP-ENV:Envelope>]]></screen>
		</para>
			
		<para>
There are two browser profiles for single sign-on (SSO) defined in SAML: artifact and 
POST. The browser/artifact profile of SAML mandates the usage of a SAML artifact in 
the URL of the HTTP 302 (redirect) status. The browser/POST profile of SAML uses an 
HTML <![CDATA[<FORM...>]]> to pass assertions directly to a destination site.
</para>
			
		<para>
An artifact is a pointer to an assertion. A SAML artifact is the base 64 encoding of the 
TypeCode and RemainingArtifact ( B64(TypeCode RemainingArtifact) ). The TypeCode is a 2 
byte number in hex notation (example 0x0001). The TypeCode value determines the 
format of the RemainingArtificact. 0x0001 is the only mandated TypeCode and is 
associated with a RemainingArtifact with the following format:
</para>
			
		<para>
			<screen>
RemainingArtifact := SourceID AssertionHandle 
SourceID := 20-byte_sequence
AssertionHandle := 20-byte_sequence</screen>
		</para>
		<para>
The SourceID has to be unique among all possible source sites. The SourceID is similar 
to an IP address but you should not use an IP address or anything that can help an 
attacker infer your identity. The AssertionHandle can be any value that identifies an 
assertion but it MUST be infeasible to construct or guess the value of a valid 
assertion or any part of an assertion from the AssertionHandle. An artifact is used 
because most Web/application servers have limitations on URL length. Lets look at the 
SSO profile in more depth.
</para>
		<para>
The Web browser SSO profile of SAML defines a scenario where an authenticated user 
from a source site wants to access a resource at a destination site without having to log in 
again. When the user wants to access the destination site he/she selects a link which 
references an inter-site transfer URL. The inter-site transfer URL is located on the source 
site and has a mandatory Target parameter in its query string. The value that the target 
equals (http://www.sourcesite.com/interSiteURL?Target=ebay_Auctions_Cars) is a logical key for a 
resource at the destination site. The Target is a name that the source site uses to reference 
the resource at the destination site. The source site uses the logical key to identify the 
URL to the Assertion consumer at the destination site as well as the destination site's 
name for that resource. If the artifact profile is being used, the source site returns a 
HTTP 302 status to the browser with a URL that points to the assertion consumer and a 
TARGET parameter which defines the name for the requested resource that the 
destination site uses. The destination site receives the artifact and then makes an out-of-
band request to the source site's artifact consumer and receives an assertion from the 
source site. If the destination site accepts the returned assertion, the user is allowed 
access to the resource. 
</para>
		<para>
When the POST profile is being used, the inter-site URL returns an HTML page to the 
browser that contains a SAML assertion. The page with the SAML assertion is then 
posted (by JavaScript) to the destination site assertion consumer URL. Here is an 
example:
</para>
			
		<para>
			<screen><![CDATA[
<HTML><Body Onload="document.forms[0].submit()">
<FORM Method="Post" Action="<assertion consumer host name and path>" ...> 
<INPUT TYPE="hidden" NAME="SAMLResponse" Value="B64(<response>)"> 
... 
<INPUT TYPE="hidden" NAME="TARGET" Value="<Target>"> 
</Body></HTML>]]></screen>
		</para>
			
		<para>
		The destination site receives the Assertion and resource name and then allows or denies 
		access to the destination site resource.
	</para>
			
		<para>
		There are two different names for the same resource (Target and TARGET). Target is 
		the source site's name for the remote resource. TARGET is the destination site's name 
		for their local resource. This is done to isolate changes in one company's environment 
		from the other. If the destination site decides to rearrange it web pages and resources, I 
		don't have to change any code because all of my code references the local name. I just 
		have to change the remote name that my local name is mapped to.
	</para>
			
		<para>
		If your security requirements do not exactly fit within the standard SAML XML 
		elements, you can extend SAML.
	</para>
	</sect2>
	<sect2>
		<title>Extending SAML elements</title>
		<para>
		There are two ways to extend SAML elements. The first is direct extension using the 
		xsi:type attribute. The second way is through substitution groups. Depending on your 
		XML instance requirements you will pick either option. 
		</para>
			
		<para>Direct Extension</para>
			
		<para>
		You use direct extension when you do not want to change the physical names of the 
		XML elements within the SAML schema and only want to add additional elements or 
		restrict existing sub elements value ranges. Here is an example how you could define 
		your own XML schema that extends the saml:StatementAbstractType:
		</para>

			
		<para>
			<screen><![CDATA[
<element name="AxiomaticKeyStatement" type="yourPrefix:AxiomaticKeyStatementType"/>
<complexType name="AxiomaticKeyStatementType">
<complexContent>
<extension base="saml: StatementAbstractType">
<sequence>
<element ref="yourPrefix:AxiomaticKey"/>
</sequence>
</extension>
</complexContent>
</complexType>]]></screen>
		</para>
			
		<para>
		Here is an actual instance of your custom extended AxiomaticKeyStatement.
		</para>
		
		<para>
			<screen><![CDATA[
<saml:Assertion ...>
<saml:Statement xsi:type="yourPrefix:AxiomaticKeyStatement">
<yourPrefix:AxiomaticKey>
<ds:KeyInfo>
<ds:KeyName>MasterKey</ds:KeyName>
<ds:KeyValue>
<ds:RSAKeyValue>
<ds:Modulus>998/T2PUN8HQlnhf9YIKdMHHGM7HkJwA56UD0a1oYq7EfdxSXAidruAsz
NqBoOqfarJIsfcVKLob1hGnQ/l6xw==</ds:Modulus>
<ds:Exponent>AQAB</ds:Exponent>
</ds:RSAKeyValue>
</ds:KeyValue>
</ds:KeyInfo>
</yourPrefix:AxiomaticKey>
</saml:Statement>
</saml:Assertion>]]></screen>
		</para>
			
		<para>
		Notice that we extended from the base type of Statement and not from Statement directly. 
		The xsi:type attribute is mandatory when we extend in this manner. We are still using 
		the saml:Statement element but we have added additional elements within it. The other 
		way we can extend SAML is through substitution groups.
		</para>
		<para>Substitution Groups</para>
		<para>Substitution groups allow you to create your own named elements and use them in place 
		of existing SAML elements. Reusing the example from above:
		</para>
		<para>
			<screen><![CDATA[
<element name="AxiomaticKeyStatement" type="yourPrefix:AxiomaticKeyStatementType"
substitutionGroup="saml:Statement"/>
<complexType name="AxiomaticKeyStatementType">
<complexContent>
<extension base="saml: StatementAbstractType">
<sequence>
<element ref="yourPrefix:AxiomaticKey"/>
</sequence>
</extension>
</complexContent>
</complexType>]]></screen>
		</para>
		<para>
		Here is an actual instance of your custom extended AxiomaticKeyStatement using 
		substitution groups.
		</para>
		<para>
			<screen><![CDATA[
<saml:Assertion ...>
<yourPrefix:AxiomaticKeyStatement>
<yourPrefix:AxiomaticKey>
<ds:KeyInfo>
<ds:KeyName>MasterKey</ds:KeyName>
<ds:KeyValue>
<ds:RSAKeyValue>
<ds:Modulus>998/T2PUN8HQlnhf9YIKdMHHGM7HkJwA56UD0a1oYq7EfdxSXAidruAsz
NqBoOqfarJIsfcVKLob1hGnQ/l6xw==</ds:Modulus>
<ds:Exponent>AQAB</ds:Exponent>
</ds:RSAKeyValue>
</ds:KeyValue>
</ds:KeyInfo>
</yourPrefix:AxiomaticKey>
</yourPrefix:AxiomaticKeyStatement>
</saml:Assertion>]]></screen>
		</para>
		<para>
		Although either method is semantically correct. Direct extension is the preferred 
		methods because it introduces less of a dependency on the external custom schema and 
		works with most schema validators. Although it is possible to extend any SAML element using 
		XML Schema's extension mechanism SAML defines several explicit extension points
		</para>
		<para>Where you can extend the SAML schema</para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>Statement</para>
				<para>
				The type it is based on is abstract and empty. You will extend from this 
				element's type when you want to create your own type of Statement, which does not 
				resemble any of SAML's Statement subtypes.</para>
			</listitem>
			<listitem>
				<para>SubjectStatement</para>
				<para>The type it is based on is abstract and has a Subject nested element.
				</para>
			</listitem>
			<listitem>
				<para>Condition</para>
				<para>The type it is based on is abstract and empty. Again you will extend from this element's type when you want to create your own type of Condition, which does not 
				resemble any of SAML's Condition subtypes. Conditions can be extended to contain 
				additional Condition subtypes. But if the party receiving an assertion cannot understand 
				your custom Condition subtype then they will have to consider the assertion 
				Indeterminate.</para>
			</listitem>
			<listitem>
				<para>Query</para>
				<para>The type it is based on is abstract and empty. You will extend from this element's type when you want to create your own Query type, which does not resemble 
				any of SAML's Query subtypes.</para>
			</listitem>
			<listitem>
				<para>SubjectQuery</para>
				<para>The type it is based on is abstract and has a Subject nested element.  You will extend this element's type when you want to create your own Query type and 
				reuse the nested saml:Subject element.</para>
			</listitem>
		</itemizedlist>
		<para>If you need to add additional attributes or nested elements within the following elements 
		they are feasible extension points as well:</para>
		<itemizedlist>
			<listitem>
				<para>AuthenticationStatement</para>
			</listitem>
			<listitem>
				<para>AttributeStatement</para>
			</listitem>
			<listitem>
				<para>AuthorizationDecisionStatement</para>
			</listitem>
			<listitem>
				<para>AudienceRestrictionCondition</para>
			</listitem>
			<listitem>
				<para>Request</para>
			</listitem>
			<listitem>
				<para>AuthenticationQuery</para>
			</listitem>
			<listitem>
				<para>AuthorizationDecisionQuery</para>
			</listitem>
			<listitem>
				<para>AttributeQuery</para>
			</listitem>
			<listitem>
				<para>Response</para>
			</listitem>
		</itemizedlist>
		<para>
		The following elements have<![CDATA[ <any> ]]>elements within them or are of type "anyType" and 
		therefore can serve as extension points without requiring external XML schema 
		definition.
		</para>
		<para>
			<screen><![CDATA[
AttributeValue     (type="anyType")
Advice             (has nested element <any namespace="##other" processContents="lax" />)]]></screen>
		</para>
			
		<para>
		The Assertion and Statement types can be extended to create customized Assertion and Statement types but 
		this can break interoperability.  The major drawback to creating your own extension is interoperability. Make 
		sure you understand the outcome if any of the interacting parties do not understand your custom 
		extensions.
		</para>
			
		<para>
		Assertions are usually signed to prove that the Assertion generated came from the entity 
		that signed the Assertion.
		</para>
	</sect2>
	<sect2>
		<title>Using Digital Signatures with SAML</title>
		<para>
		XML Signature (XS) provides integrity and authentication for XML elements within a 
		document. XS ensures certain parts of a XML document are unaltered and created by the 
		party that signed the document. XS adds additional complexity by requiring interacting 
		parties to negotiate canonicalization methods, key sharing, XML transformations, and 
		hashing algorithms at the application level. In most cases, where the relying party and 
		asserting party are communicating directly to each other, mutual authentication over 
		SSL/TLS will provide authentication, integrity, confidentiality, and can form the basis for 
		non-repudiation. In other cases, where intermediaries separate the relying and 
		asserting parties XS becomes crucial.
		</para>
			
		<para>
		Although any XML element within a SAML document could be signed, SAML only 
		specifies 3 elements that should be signed: samlp:Request, samlp:Response, and 
		saml:Assertion. SAML specifies support of enveloped signatures. Enveloped signatures 
		describe an XML layout where the ds:Signature element is "enveloped" by the XML 
		document or element that it is signing. The ds:Signature element in a saml:Assertion 
		element follows the saml:Advice element. 
		</para>
			
		<para>
			<screen><![CDATA[
<element name = "Assertion" type = "saml:AssertionAbstractType"/>
<complexType name = "AssertionAbstractType" abstract = "true"> 
<sequence> 
<element ref = "saml:Conditions" minOccurs = "0"/> 
<element ref = "saml:Advice" minOccurs = "0"/> 
<element ref = "ds:Signature" minOccurs="0" maxOccurs="1"/> 
</sequence> 
<attribute name = "MajorVersion" use = "required" type = "integer"/> 
<attribute name = "MinorVersion" use = "required" type = "integer"/> 
<attribute name = "AssertionID" use = "required" type = "saml:IDType"/> 
<attribute name = "Issuer" use = "required" type = "string"/> 
<attribute name = "IssueInstant" use = "required" type = "timeInstant"/> 
</complexType>]]></screen>
		</para>
		<para>
		ds:Signature signs. (For details on the ds:Signature element refer to the Digital 
		Signature section of the XML Security Chapter). Signing a samlp:Request or 
		samlp:Response works in a similar fashion. </para>
		<para>
			<screen><![CDATA[
<complexType name="RequestAbstractType" abstract="true"> 
<attribute name="RequestID" type="saml:IDType" use="required"/> 
<attribute name="MajorVersion" type="integer" use="required"/>
<attribute name="MinorVersion" type="integer" use="required"/>
<element ref = "ds:Signature" minOccurs="0" maxOccurs="1"/>
</complexType>

<complexType name="ResponseAbstractType" abstract="true"> 
<attribute name="ResponseID" type="saml:IDType" use="required"/>
<attribute name="InResponseTo" type="saml:IDType" use="required"/>
<attribute name="MajorVersion" type="integer" use="required"/>
<attribute name="MinorVersion" type="integer" use="required"/> 
<element ref = "ds:Signature" minOccurs="0" maxOccurs="1"/>
</complexType>]]></screen>
		</para>
		<para>
		In both cases, the ds:Signature signs the samlp:Request or samlp:Response that envelops 
		it. In some cases a super signature can implicitly sign SAML elements. A super 
		signature is a ds:Signature that signs a XML element which envelops all mandatory 
		elements within a saml:Assertion, samlp:Request or samlp:Response. For example, if a 
		samlp:Request was being transported within a SOAP-ENV:Body and that SOAP-
		ENV:Body element was signed then the samlp:Request inherits its signature from the 
		super-signature on the SOAP-ENV:Body element. If a saml:Assertion needs to be sent to 
		a relying party through an intermediary than it cannot use a super-signature and has to 
		use the signing methods defined above.
		</para>
	</sect2>
	<sect2>
		<title>Securing SAML</title>
		<para>
		The best way to secure SAML interactions is to ensure confidentiality, integrity, and 
		mutual authentication between every interacting party of a SAML transaction--weather the 
		party is an end point or intermediary. This implies the use of a secure transport protocol 
		such as IPSec, SSH, SSL, or TLS between all interacting parties. Exposing signed (using 
		XML Signature) and encrypted (using XML Encryption) SAML assertions over non-
		secure protocols such as HTTP allows for replay and denial of service attacks.
		</para>
		<para>
		XML Signature is still required in cases where the assertion generated flows through an 
		intermediary. The XML Signature on the Assertion guarantees that the Assertion is from 
		the originator (signer) not intermediary. In this case where you are using a secure 
		transport protocol such as SSL, XMLEncryption only provides value when you don't 
		want to share Assertion contents with intermediaries.
		</para>
		<para>
		When you are using both XML 
		Signature and XML Encryption together you should first sign and then encrypt the 
		assertion being passed. This hides the identity of the signer and its key. In addition, you 
		will want to use a CBC (cipher block chained) or stream encryption algorithm to protect 
		against certain attacks as outlined in The Order of Encryption and Authentication
		for Protecting Communications by Hugo Krawczyk. For more information on XML 
		Encryption check out the chapter on XML Encryption.
		</para>
		<para>
		In some cases assertions are long 
		lived and need to be stored. In most cases they should never be stored on the local file 
		system. Ideally, long-lived assertions should be encrypted (by the database) and stored in 
		a (UTF8 character set encoding) database. UTF8 is the defacto-encoding standard for 
		internationalization and XML vocabularies. To minimize the possibility of Replay 
		attacks all members of a federated authentication system will need to generate assertions 
		with expiration dates or sequence numbers. If expiration dates are used, all participating 
		members will need to run Network Time Protocol (NTP) to ensure assertions are not still 
		born. 
		</para>
	</sect2>
		
	<sect2>
		<title>Weakness of Federated Security Systems</title>
		<para>
		Single sign-on between disparate systems involves giving up defense in depth and 
		opening up your application to more points of attack. In most cases you have no control 
		over the security policies that partner sites impose. Some partner sites might allow 
		passwords that are easily guessed or might not require users to change their password 
		often. In other cases, partner sites may not have good security practices in general. The 
		probably of your site being compromised becomes the probability of the worst run site in 
		your federation.
		</para>
	</sect2>
	<sect2>
		<title>Summary</title>
		<para>
		SAML is showing a lot of promise. It is the first time that all of the major vendors have 
		come together to support a single standard for sharing security related information. There 
		are still issues to resolve like how users are mapped to different systems. Luckily the 
		SAML group is working on this for 2.0 which will be released soon.
		</para>
	</sect2>
</sect1>
	
