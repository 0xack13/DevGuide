<!-- $Id: common_problems.xml,v 1.18 2003/04/03 13:55:59 awiesmann Exp $ -->
<chapter id="ch11">
	<chapterinfo>
		<authorgroup>
			<author>
				<firstname>Gene</firstname>
				<surname>McKenna</surname>
			</author>
			<author>
				<firstname>Jeremy</firstname>
				<surname>Poteet</surname>
			</author>
		</authorgroup>
	</chapterinfo>
	<title>Preventing Common Problems</title>
	<sect1>
		<title>Introduction</title>
		<para>
      This chapter describes other common problems that web
      applications typically exhibit and that web application
      developers commonly make.  These problems usually are not a
      result of the specific languages or tools used to build the
      application, but are a direct result of ignorance of the issues
      revolving around application security or reliance on faulty
      procedures and techniques for securing the application.
      </para>
		<para>
      The issues addressed in this chapter will not lock down an
      application but can be used to complement the specific items
      addressed in other chapters.  Understanding these concepts will
      deepen your knowledge of application security principles and
      will allow you to mitigate these common risks.
      </para>
		<para>
      These concepts fall into the following categories:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            Tools - While these common problems are not
            restricted to one language or tool, the use of tools
            is a necessary component in application development
            and the misuse of these tools can expose significant
            security vulnerabilities.
            </para>
			</listitem>
			<listitem>
				<para>
            Information Disclosure - Applications that disclose
            sensitive information can be used to gain
            information to launch further attacks or to mine the
            application for data.
            </para>
			</listitem>
			<listitem>
				<para>
            File Access - Failure to properly restrict file
            access can expose source code, configuration and
            even data files.
            </para>
			</listitem>
		</itemizedlist>
	</sect1>
	<sect1>
		<title>Tools</title>
		<sect2>
			<title>Vendor Patches</title>
			<sect3>
				<title>Description</title>
				<para>
            Vulnerabilities are common within 3rd party tools and
            products that are installed as part of the web
            applications.  These web servers, application servers,
            e-commerce suites, etc. are purchased or downloaded from
            external vendors and installed as part of the site. The
            vendor typically addresses security vulnerabilities by
            supplying a patch that must be downloaded and installed as
            an update to the product at the customer's site.
            </para>
				<para>
            The large numbers of tools used on most web sites along
            with the proliferation of application security
            vulnerabilities makes keeping up with vendor security
            patches a significant issue.  With new versions of tools
            being released and more vulnerabilities being disclosed,
            it can seem overwhelming to ensure that all of the proper
            patches have been applied.  To compound the issue, some of
            the major worms such as CodeRed, Slapper and Slammer, were
            based on the basic issue of attacking machines where the
            proper security patches had not been applied.
            </para>
				<para>
            In order to begin to address the issue, the first thing to
            resolve is to determine what tools are installed on the
            server.  While this may seem to be a simple question, many
            administrators are only aware of the major tools on the
            site, but many smaller or bundled tools go unnoticed or
            have been long forgotten.  Since no one is aware of and
            actively monitoring these tools, any security patches that
            become available are unlikely to be applied.
            </para>
				<para>
            Once a comprehensive list of tools is compiled, prior to
            determining what patches exist and how patches will be
            applied, the first issue is whether these tools need to be
            installed.  While many of the tools may serve an important
            purpose, most servers will accumulate various tools and
            components that are no longer used by the applications and
            can be purged from the servers.  Rather than trying to
            keep obsolete or unneeded tools updated, removing them
            from the server is a much better approach.
            </para>
				<para>
            Once you have a complete list of all of the tools and
            components that should be on the various servers, the next
            step is to determine how each tool vendor you use
            discloses security patches.  How patch information is made
            available varies widely from vendor to vendor.
            </para>
				<para>
            All products have vulnerabilities that are discovered in
            an ongoing manner and in most cases disclosed directly to
            the vendor (although there are also cases in which the
            vulnerability is revealed to the public without disclosure
            to the vendor). The vendor will typically address the
            vulnerability by issuing a patch and making it available
            to the customers using the product, with or without
            revealing the full vulnerability. The patches are
            sometimes grouped in patch groups (or service packs) that
            may be released periodically.
            </para>
				<para>
            Most patches are released by the vendors only in their
            site and in many cases published only in internal mailing
            lists or sites. Sites and lists following such
            vulnerabilities and patches (such as bugtraq) do not serve
            as a central repository for all patches. There are often
            numerous patches for mainstream products every month.
            Another critical aspect of patches is that they are not
            (in most cases) signed or contain a checksum causing them
            to be a potential source of Trojans in the system.
            </para>
				<para>
            In order to be aware of available patches, you should
            subscribe to your vendors' security intelligence service
            for all software that forms a part of your web application
            or a security infrastructure.  Some vendors have a tool
            that can assist users in determining missing patches.
            Others rely on manually checking the web site for new
            versions of products.  The more tools used on a site, the
            more likely that a wide variety of approaches will be
            required.
            </para>
				<para>
            In looking at the vendor solutions for patch management,
            it may become clear that dealing with more "reputable"
            vendors or groups is a better approach.  While tools are
            created by vendors and groups of all sizes, those with the
            resources to patch vulnerabilities in a timely manner,
            test the patches adequately, and provide disclosure
            information to their customers can significantly reduce
            the effort required by their users.  Patch management
            should be a factor in determining what vendors to use or
            even in looking at reducing the vendors used to a more
            manageable list.
            </para>
				<para>
            Once you have determined how each vendor releases patches,
            you need to develop a plan for when to gather and apply
            patches.  If the vendors you use are proactive in
            informing you of security patches, when to gather patches
            is a non-issue.  However, for those tools where the user
            is required to be the proactive party, you need to
            determine how often you will conduct the manual check for
            new releases.  Once you have a documented plan on when to
            gather patches, you need to determine when to apply them.
            Patches are software and therefore will have bugs and
            security flaws of their own.  Applying a patch as soon as
            it comes out is not always the best approach, especially
            if the vulnerability being patched is a low risk for your
            organization.  Having a well thought out plan in place can
            make the determination of when to apply patches an easy
            step.
            </para>
				<para>
            Before applying patches, it is best to apply them first to
            a test bed and ensure that both the patch and the
            applications on the server perform appropriately.  This is
            another reason for creating automated tests for your
            applications.  There are many non-security related reasons
            as well, but automated tests can make this test stage
            manageable.
            </para>
				<para>
            Once the patch has been adequately tested, the next step
            is to ensure the patch has been applied to all effected
            servers.  Any server that is missed may be enough to cause
            significant problems if the vulnerability is exploited.
            Along with ensuring all servers have been patched, create
            a change log of what patches were applied, to what servers
            and when the changes were made.  This will be invaluable
            in the event of a problem that was undetected during the
            testing stage.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Create a list of all tools and components on the
                  server
                  </para>
					</listitem>
					<listitem>
						<para>
                  Remove any tools or components that are not needed
                  </para>
					</listitem>
					<listitem>
						<para>
                  Determine the security patch process for every
                  vendor on the list
                  </para>
					</listitem>
					<listitem>
						<para>
                  Produce a plan for when to check for security
                  patches for every tool on the list
                  </para>
					</listitem>
					<listitem>
						<para>
                  Produce a plan for when to apply security patches
                  </para>
					</listitem>
					<listitem>
						<para>
                  Create a test bed for testing the security patch
                  </para>
					</listitem>
					<listitem>
						<para>
                  Apply security patch to all effected machines
                  </para>
					</listitem>
					<listitem>
						<para>
                  Create a change log to track all security patches
                  that are applied
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>System Configuration</title>
			<sect3>
				<title>Description</title>
				<para>
            Server software is often complex, requiring much
            understanding of both the protocols involved and their
            internal workings to correctly configure. Unfortunately
            software makes this task much more difficult by providing
            default configurations which are known to be vulnerable to
            devastating attacks. Often "sample" files and directories
            are installed by default which may provide attackers with
            ready-made attacks should problems be found in the sample
            files. While many vendors suggest removing these files by
            default, they put the onus of securing an "out of the box"
            installation on those deploying their product. A (very)
            few vendors attempt to provide secure defaults for their
            systems (the OpenBSD project being an example). Systems
            from these vendors often prove much less vulnerable to
            widespread attack. This approach to securing
            infrastructure appears to work very well and should be
            encouraged when discussing procurement with vendors.
            </para>
				<para>
            If a vendor provides tools for managing and securing
            installations for your software, it may be worth
            evaluating these tools, however they will never be a full
            replacement for understanding how a system is designed to
            work and strictly managing configurations across your
            deployed base.
            </para>
				<para>
            Understanding how system configuration affects security is
            crucial to effective risk management. Systems being
            deployed today rely on so many layers of software that a
            system may be compromised from vectors, which may be
            difficult or impossible to predict. Risk management and
            threat analysis seeks to quantify this risk, minimize the
            impact of the inevitable failure, and provide means (other
            than technical) for compensating for threat
            exposure. Configuration management is a well-understood
            piece of this puzzle, yet remains maddeningly difficult to
            implement well. As configurations and environmental
            factors may change over time, a system once well shielded
            by structural safeguards may become a weak link with very
            little outward indication that the risk inherent in a
            system has changed.  Organizations will have to accept
            that configuration management is a continuing process and
            cannot simply be done once and let be. Effectively
            managing configurations can be a first step in putting in
            place the safeguards that allow systems to perform
            reliably in the face of concerted attack.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Create a list of all tools and components on the
                  server
                  </para>
					</listitem>
					<listitem>
						<para>
                  Remove any tools or components that are not needed
                  </para>
					</listitem>
					<listitem>
						<para>
                  Understand the settings and configurations of all
                  tools used on the server
                  </para>
					</listitem>
					<listitem>
						<para>
                  Utilize any vendor tools that aid in security the
                  configuration
                  </para>
					</listitem>
					<listitem>
						<para>
                  Version control all configuration files to ease in
                  making changes over time
                  </para>
					</listitem>
					<listitem>
						<para>
                  Ensure all configuration changes are synchronized
                  over all instances of the tool
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>Default Accounts</title>
			<sect3>
				<title>Description</title>
				<para>
            Many "off the shelf" web applications and tools typically
            include various default user accounts that are activated
            by default.  These accounts are typically set up for:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Administrator accounts
                  </para>
					</listitem>
					<listitem>
						<para>
                  Test accounts
                  </para>
					</listitem>
					<listitem>
						<para>
                  Guest accounts
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            In those cases where there is only one account configured,
            it is typically for the administrator of the system.
            These default user accounts come pre-configured on the
            system and in many cases have a standard password, which
            is documented or widely known. Moreover, most applications
            do not force a change to the default password.  These
            accounts can be accessed using the standard login page for
            all defined accounts or via special ports or URLs within
            the application, such as administrator pages.
            </para>
				<para>
            While this is typically seen as a problem with "off the
            shelf" software, custom software can exhibit the same
            issues.  Developers often use standard logins and
            passwords for web applications, which can cause the same
            problem as their "off the shelf" counterparts. Too often,
            the passwords are the same as the ids or some other easily
            guessed value. Common ids include:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  admin
                  </para>
					</listitem>
					<listitem>
						<para>
                  system
                  </para>
					</listitem>
					<listitem>
						<para>
                  sys
                  </para>
					</listitem>
					<listitem>
						<para>
                  dev
                  </para>
					</listitem>
					<listitem>
						<para>
                  guest
                  </para>
					</listitem>
					<listitem>
						<para>
                  test
                  </para>
					</listitem>
					<listitem>
						<para>
                  demo
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            If the default values are not modified or accounts with
            common values are created, the system can then be
            compromised by attempting access using these default
            values.  The attack on such default accounts can occur in
            two ways:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Attempt to use the default username/password
                  assuming that it was not changed during the default
                  installation.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Enumeration over the password only, since the user
                  name of the account is known.
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            Enumeration over the password is normally mitigated by
            locking an account after a certain number if invalid login
            attempts.  However, these default or common accounts
            sometimes use different rules than other accounts.  For
            example, an admin user account may not lock after three
            invalid login attempts, because that is the account that
            is used to unlock user accounts.  On the other hand, if
            there is no special logic it may be possible to lock the
            admin user account with invalid attempts.  If this was not
            anticipated, this could prove difficult for the real admin
            user to work around.  Locking out accounts, such as admin,
            guest or demo, usually will cause problems on the site as
            legitimate users of those accounts can no longer access
            the application.
            </para>
				<para>
            Once the password is entered or guessed then the attacker
            has access to the site according to the account's
            permissions, which usually leads in two major directions:
            </para>
				<para>
            If the account was an administrator account then the
            attacker has partial or complete control over the
            application (and sometimes, the whole site) with the
            ability to perform any malicious action.  Even test
            accounts can fall into this category, as the attacker
            would have whatever access is granted to the account.  If
            the test account was granted certain administrative
            privileges for testing purposes, those authorization
            credentials will now be granted to the attacker.
            </para>
				<para>
            If the account was a demo or test account the attacker can
            use this account as a means of accessing and abusing the
            application logic exposed to that user and using it as a
            means of progressing with the attack.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Audit the list of user accounts to the application
                  </para>
					</listitem>
					<listitem>
						<para>
                  Remove all standard or common logins that are not
                  used
                  </para>
					</listitem>
					<listitem>
						<para>
                  Ensure that default or common logins are disabled or
                  changed if possible
                  </para>
					</listitem>
					<listitem>
						<para>
                  In the event that some default or common login ids
                  must remain, ensure that the passwords for those
                  accounts have been modified and meet or exceed your
                  requirements for password length and complexity.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Ensure that test accounts on the site have the
                  minimal level of permissions necessary.  Consider
                  removing test accounts from production systems
                  unless absolutely required to test production
                  issues.  In these cases consider removing the
                  accounts and adding them only when necessary.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>Information Disclosure</title>
		<sect2>
			<title>Error Messages</title>
			<sect3>
				<title>Description</title>
				<sect4>
					<title>Internal Errors</title>
					<para>
               Error messages are one of the most powerful tools at an
               application attacker's disposal.  They can be used to
               communicate sensitive data directly or to tune an attack
               syntax.  For example, look at the following error message
               from an example site:
               </para>
					<programlisting>
               Microsoft OLE DB Provider for SQL Server error '80040e14'
               Incorrect syntax near the keyword 'or'. 
               F:\WEBSITES\WWW.EXAMPLE.COM\NEWS\../internal/tools/database.asp, line 276
               </programlisting>
					<para>
               From this single error message, the attacker can glean the
               following information they would not be aware of
               otherwise:
               </para>
					<itemizedlist mark="opencircle" spacing="compact">
						<listitem>
							<para>
                     The application uses OLE DB to communicate to the
                     database
                     </para>
						</listitem>
						<listitem>
							<para>
                     The application uses SQL Server as the database
                     </para>
						</listitem>
						<listitem>
							<para>
                     SQL commands can be passed to the database
                     </para>
						</listitem>
						<listitem>
							<para>
                     The application is store in the
                     F:\Websites\www.example.com directory on the web
                     server
                     </para>
						</listitem>
						<listitem>
							<para>
                     There is a directory called internal/tools on the
                     website
                     </para>
						</listitem>
						<listitem>
							<para>
                     There is an internal file called database.asp on the
                     website
                     </para>
						</listitem>
						<listitem>
							<para>
                     Line 276 of the database.asp page contains code to
                     execute a SQL statement
                     </para>
						</listitem>
					</itemizedlist>
					<para>
               All of this information can be used directly or indirectly
               in launching other attacks against the website.
               Protecting this information needs to be a key aspect of
               the application security model.
               </para>
					<para>
               All exceptions from the database, file handling,
               etc. should be caught and logged, but never displayed back
               to the user.  Only general error messages should be
               displayed back to the user to avoid disclosing internal or
               sensitive information to an attacker.
               </para>
				</sect4>
				<sect4>
					<title>Application Errors</title>
					<para>
               Another area of error messages that must be carefully
               managed involves application error messages that are
               intended for viewing by the user.  While these error
               messages do not contain internal information relating to
               the technical details of the application, they can be used
               to mine the application for information and can
               inadvertently expose sensitive information.
               </para>
					<para>
               An example of this would be a login page that indicates
               that the "User ID is invalid" rather than "The User ID and
               Password do not match".  By indicating that the user ID is
               invalid, the application can be used to extract a valid
               list of user IDs from the site.  This may be used to
               attempt to impersonate other users or conduct an
               application DOS by locking out large numbers of user
               accounts.  Registration pages and password reminder
               questions are also notorious for these types of data
               mining errors.
               </para>
					<para>
               The content of the application error messages is not the
               only vulnerability that can exist in this area.  Many
               times information can be mined simply by the timing of the
               messages.  For instance, if we look at a registration
               page, there are numerous fields that may generate a
               variety of error messages.  By trial and error, an
               attacker may be able to reconstruct the server code by
               watching the cause and effect of the error message
               handling.
               </para>
					<table frame="all">
						<title/>
						<tgroup cols="2" align="left" colsep="1" rowsep="1">
							<colspec colname="c1"/>
							<colspec colname="c2"/>
							<thead>
								<row>
									<entry align="center">
                           Action
                           </entry>
									<entry align="center">
                           Error Message
                           </entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
                           Leave user ID blank
                           </entry>
									<entry>
                           The User ID is required
                           </entry>
								</row>
								<row>
									<entry>
                           Fill in user ID with existing ID
                           </entry>
									<entry>
                           The User ID is already in use
                           </entry>
								</row>
								<row>
									<entry>
                           Fill in user ID with new ID
                           </entry>
									<entry>
                           The Password is required
                           </entry>
								</row>
								<row>
									<entry>
                           Fill in password
                           </entry>
									<entry>
                           The Verify Password is required
                           </entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>
               The code to cause the above behavior would look something
               like this:
               </para>
					<programlisting>
               If(request("userID") = "") Then
               errMessage = "The User ID is required"
               Else If(checkForDups(request("userId")) = true) Then
                   errMessage = "The User ID is already in use"
               Else If(request("password") = "") Then
                   errMessage = "The Password is required"
               Else If(request("password2") = "") Then
                   errMessage = "The Verify Password is required"
               ...
               </programlisting>
					<para>
               This information can be very helpful to an attacker in
               forming the attacks to be successful without spending much
               time in trial and error attempts.  This reduces the
               chances of catching the attacker and leaves the site in a
               more vulnerable state.
               </para>
				</sect4>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Create a general error page
                  </para>
					</listitem>
					<listitem>
						<para>
                  Catch all exceptions, unexpected errors, etc. and
                  redirect the user to the general error page
                  </para>
					</listitem>
					<listitem>
						<para>
                  Review all application error pages in light of how
                  those errors can be used to mine information from
                  the site
                  </para>
					</listitem>
					<listitem>
						<para>
                  Observe how individual errors are returned by the
                  application and see if the algorithms or code
                  structure can be gleaned from the order of the
                  messages
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>Comments</title>
			<sect3>
				<title>Description</title>
				<para>
            Comments placed in source code aids readability and
            improves documented process. It is an important process
            that many companies try very hard to instill in
            developers.  The practice of commenting has been carried
            over into the development of HTML pages and scripting
            code, which are sent to the clients' browser. As a result,
            information about the structure of the web site or
            information intended only for the system owners or
            developers can be inadvertently revealed.  The same
            information that is valuable to those who maintain the
            site is also of interest to those who attack it.
            </para>
				<para>
            Comments left in HTML and scripts can come in many
            formats, some as simple as directory structures, others
            inform the potential attacker about the true location of
            the web root. Comments are sometimes left in from the HTML
            development stage and can contain information such as:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  developer names, user ids, email addresses and phone
                  numbers.  This information can be valuable for
                  conducting social engineering attacks or providing
                  potential developer ids to attempt login access
                  with.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Internal filenames
                  </para>
					</listitem>
					<listitem>
						<para>
                  Old code
                  </para>
					</listitem>
					<listitem>
						<para>
                  Instructions on how bugs were worked around, how to
                  modify the code to accomplish other tasks, etc.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Server information, such as internal IP addresses,
                  server names, etc.  This is often found on
                  applications that reside on a web server farm.  This
                  information can be used to map the server farm.
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            Comments are added for various reasons and by different
            mechanisms.  Understanding why they are added can assist
            in determining how to mitigate this risk.
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Structured Comments - these appear in script or HTML
                  source, usually at the top of the page.  These
                  usually follow some corporate or team standard and
                  include common information about the developers,
                  what has been changed, dependencies, etc. For
		  scripting languages such as Perl, JSP and ASP, script
		  comments don't usually make their way to the user
		  and are therefore less of a threat. (However, server
		  vulnerabilities can sometimes allow the script source
		  to be exposed as well which reveals not only the script
		  comments, but the entire script source - an even bigger
		  worry.) HTML comments, on the other hand, are always sent to the user or
		  system requesting the HTML resource and therefore pose
		  a significant threat if the comments reveal information
		  about the system. Developers using a scripting language
		  such as Perl, JSP or ASP should have much less need for
		  HTML comments since they can often substitute
		  script comments instead.
		  </para>
					</listitem>
					<listitem>
						<para>
                  Automated Comments - many widely used page
                  generation utilities and web usage software
                  automatically add signature comments into the HTML
                  page. These will inform the attacker about the
                  precise software packages (sometimes even down to
                  the actual release) that is being used on the
                  site. Known vulnerabilities in those packages can
                  then be tried out against the site.  These tools
                  also may include other information, such as version
                  control tools which include the version number and
                  sometimes version history of the file in a comment
                  block.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Unstructured Comments - these are one off comments
                  made by developers to comment a particular piece of
                  code or HTML. These can be particularly dangerous,
                  as they are not controlled in any way. Comments such
                  as "The following hidden field must be set to 1 or
                  XYZ.asp breaks" or "Don't change the order of these
                  table fields" can signal a red flag to a potential
                  attacker. Again, unstructured HTML comments will
		  always go the requester of the HTML resource, whereas
		  unstructued script comments might not depending
		  on the environment.
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            For many situations, a simple filter that strips HTML comments
            before pages are included in a build is all
            that is required. The build process may allow for HTML comments
	    to be included in development builds, but would remove them in
	    QA and production builds, reflecting the need that comments
	    are often helpful to developers for debugging, but also
	    recognizing that it isn't sound practice to put something
	    into production that isn't exactly what was tested in a QA
	    cycle. Other options include configuring source code control
	    systems to reject resources with any HTML comments. CVS,
	    for example, can easily be configured to do this.
	    </para>
				<para>
	    For automated comments an active filter may be
            required or configuring the tool to prevent the inclusion
            of these comments. 
	    </para>
				<para>
	    It is good practice to tie the filtering process to sound
            deployment methodologies so that only known good pages are
            ever released to production. 
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Add a filter to the deployment or build process to remove
                  comments from HTML and script files.
                  </para>
					</listitem>
					<listitem>
						<para>
                  For comments added by tools, determine if tool can
                  be configured to eliminate the adding of the
                  comments into the source code files.
                  </para>
					</listitem>
					<listitem>
						<para>
                  In the case of automated comments, where the tool
                  cannot be configured, consider adding an active
                  filter to strip out comments before returning the
                  page to the browser.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>Debug Commands</title>
			<sect3>
				<title>Description</title>
				<para>
            Debug commands are hooks placed by developers into the
            application to assist in debugging the application.  These
            may be attributes, which are missing from the web
            interface, but when supplied, turn on the debugging mode.
            They also may be attributes, which are a part of the
            application and simply need their value changed to turn on
            debugging.
            </para>
				<para>
            The form these debug commands take may vary from
            application to application.  They may be a form field that
            needs to be supplied or a cookie that must exist. When
            turned on, debugging mode usually provides information
            that would be very useful to an attacker.  It may disclose
            information about internal server settings, show stack
            traces or other internal errors or may allow access to
            data structures that expose sensitive data.
            </para>
				<para>
            Another risk posed by debug commands is that they are
            often susceptible to other vulnerabilities associated with
            data input validation.  Since the debug commands are
            assumed to be hidden and unknown, they often do not
            undergo the same security checks as other input fields.
            If their existence is exposed, they can cause other
            attacks to be launched successfully against the site.
            </para>
				<para>
            In some cases, debug commands can be easy to detect.  If
            the attribute is already in the application and simply
            needs a value change to trigger it, finding the command is
            easy and turning it on may be a simple process.  If the
            command is not in the user interface, it requires
            guesswork or access to the internals of the application.
            </para>
				<para>
            Guesswork usually involves appending common debug commands
            to the URLs of the application, such as "debug=on" or
            "DEBUG=YES".
            </para>
				<programlisting>
            http://www.example.com/account_check?ID=8327dsddi8qjgqllkjdlas
            </programlisting>
				<para>
            Can be altered to:
            </para>
				<programlisting>
            http://www.example.com/account_check?ID=8327dsddi8qjgqllkjdlas&amp;debug=on
            </programlisting>
				<para>
            Access to the internals of the application usually
            requires insider information or access to the source code,
            which is discussed in several sections in this chapter.
            </para>
				<para>
            Preventing debug commands from causing a security
            vulnerability is a difficult process, since the technique
            itself is based on easily providing information that
            should not be available to an attacker.  The best way is
            to remove such constructs from all production code.  This
            can be done through a preprocessor step, which strips out
            the debugging blocks of code.  Another technique would be
            to develop the architecture in such a way that a debugging
            module would be deployed in development that would provide
            the extra information, while the production version of the
            module would do nothing when called.
            </para>
				<para>
            While these techniques can prevent an attacker from
            gaining access to the debugging information, they do rely
            on the fact that the application is properly deployed.  If
            the debugging version is deployed to production, the
            application could be under significant risk.
            </para>
				<para>
            A final technique that can be used is that when debugging
            is turned on, the output is directed to a file on the
            server that an attacker cannot easily access.  Rather than
            show the debugging information on the screen, the
            developer would watch a log file for the information they
            require.  This would prevent an attacker from gaining
            access to the valuable information, and with minimal
            effort still allow the developer access to the information
            for debugging purposes.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  If no longer used, remove these debugging commands
                  from application.
                  </para>
					</listitem>
					<listitem>
						<para>
                  If still used for debugging purposes, remove the
                  commands from production code using a preprocessing
                  step or through the use of a production level
                  component.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Direct output from the debugging logs to a server
                  log rather than back to the user's browser.  This
                  will make it difficult for an attacker to obtain a
                  benefit from the debug commands even if they are
                  successful in enabling the commands.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>GET vs. POST</title>
			<sect3>
				<title>Description</title>
				<para>
            There are two methods that are commonly used to supply
            data from HTML forms to the server application: GET and
            POST.  POST can only be set by explicitly setting the
            form's method attribute to "POST".  However, GET can be
            set in multiple ways:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  explicitly set the form's method attribute to "GET"
                  </para>
					</listitem>
					<listitem>
						<para>
                  do not set the form's method attribute.  GET is the
                  default value.
                  </para>
					</listitem>
					<listitem>
						<para>
                  use the ? parameter on a URL, such a
                  http://www.example.com/news.jsp?id=123.  The id=123
                  is passed using the GET method.
                  </para>
					</listitem>
				</itemizedlist>
				<para>
            No sensitive data should be supplied to the web server
            using the GET method on a form.  The GET method should be
            reserved for fields such as supplying a news id to
            retrieve a news story.  The POST method should be used for
            all sensitive data.  For example, logging in or changing
            your password should always be done using POST.  Using GET
            may expose the plain text password in ways that are
            difficult to secure.
            </para>
				<para>
            Depending on other aspects of the application, such as the
            browser settings and the use of SSL, information passed
            using the GET request may be exposed by:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  a web server or proxy
                  </para>
					</listitem>
					<listitem>
						<para>
                  the browser's history
                  </para>
					</listitem>
					<listitem>
						<para>
                  a passerby in a "look over the shoulder" surfing attack.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Check all form submittals that deal with sensitive
                  information
                  </para>
					</listitem>
					<listitem>
						<para>
                  Change any uses of GET to POST where sensitive
                  information is being submitted
                  </para>
					</listitem>
					<listitem>
						<para>
                  If necessary, use a scripting language, such as
                  JavaScript, to set the form's attributes to the
                  proper values and the method to POST in order to
                  work around the use of GET in the ? or hyperlink
                  syntax.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>File Access</title>
		<sect2>
			<title>Server Source Code</title>
			<sect3>
				<title>Description</title>
				<para>
            Web applications often make use of scripting or
            non-compiled languages and tools for the development of
            server code.  Using such languages/tools as ASP, JSP, PHP
            and Perl fit well into a web development framework.  Teams
            can make use of web designers to create the look and feel
            and use developers to create the components that interact
            with the database and hold the business logic.  These
            types of tools also allow for the rapid development and
            quick changes that has become a critical aspect of web
            development.  While there are many reasons these tools
            have become very popular in the development of web
            applications, there are some distinct security drawbacks
            to using these concepts.
            </para>
				<para>
            Using these types of scripting tools, places the source
            code for the application on the server.  With no other
            security vulnerabilities on the site, this may not pose a
            significant problem.  However, there are numerous ways in
            which the source code for the application can be
            inadvertently exposed.  Most web servers have had
            vulnerabilities where source code could be exposed by
            manipulating the URL or utilizing a sample application
            that shipped with the product.  Also, the application
            itself may expose source code if it contains improper file
            handling code.
            </para>
				<para>
            There are steps that can be taken to reduce the risk posed
            by the use of these languages and tools.  The first is to
            reduce the amount of information an attacker can gain with
            access to the source.  With the proper use of these tools,
            issues such as exposing logins, passwords, database
            connection strings, SQL statements, etc. should not be an
            issue since those items should be relegated to other tiers
            of the application.  In reality, many applications embed
            all of these items in the GUI presentation tier, which
            makes exposure of source code a more significant risk.
            </para>
				<para>
            Another step that may help in some cases is to ensure that
            source code is kept isolated from other types of files.
            This can allow other security measures to be taken to
            prevent source code from being exposed.  For example, ASP
            pages only require scripting permission, while read
            permission is only needed for files such as HTML or
            images.  If the ASP pages are segregated to a different
            directory from other files, IIS can be configured to only
            allow scripting to those files.  Without read access to
            the ASP pages, most of the source code exposure issues are
            mitigated. Using EAR or WAR archives with J2EE servers
	    instead of free-standing or "exploded" jsp resources can
	    similarly help protect these resources.
            </para>
				<para>
            For many of these tools, the source code can be
            pre-compiled, so that the source is not deployed to the
            production server.  Hooking this step into the build and
            deployment process can significantly mitigate this risk
            and in some cases may also improve performance.
            </para>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Move sensitive information from scriptable files to
                  compiled code.  For instance, connect to the
                  database through an EJB or COM component as opposed
                  to through a JSP or ASP directly.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Segregate the source code files from other file
                  types, such as HTML, JavaScript, CSS or images.
                  This may allow the server to be configured to be
                  more restrictive in it's handling of these files.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Where possible, pre-compile the source pages and
                  only deploy their compile versions.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
		<sect2>
			<title>Unlinked Files</title>
			<sect3>
				<title>Description</title>
				<para>
            A common misconception in web applications is that
            unlinked files equates to inaccessible files.  Just
            because a file does not have a hyperlink that points to
            it, does not mean the file cannot be retrieved from the
            site.  Retrieving the file is as simple as entering the
            file name in the URL and checking to see how the web
            server responds.
            </para>
				<para>
            This technique is commonly called "forceful browsing" or
            "file enumeration".  The target file is requested from the
            web server and the HTTP server response code is checked to
            see if the file is available.  If the server responds with
            an HTTP 404 response code, the file is not available.  If
            the server responds with an HTTP 200 response code, the
            file may be available.  Some web servers will respond with
            an HTTP 200 response code and a custom HTTP 404 error
            page.  This can cause basic vulnerability scanners to
            become confused and report a large number of false
            positives.  More advanced scanners can be configured to
            recognize the custom 404 pages and respond correctly.  A
            manual test and a check if the requested page was supplied
            will also ensure the HTTP 200 code is not a false
            positive.
            </para>
				<para>
            There are a variety of file types that can be retrieved
            from a web site that may expose a system to a security
            vulnerability.  These include:
            </para>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Known Vulnerable Files - Many known vulnerable files
                  exist, and looking for them is the most common
                  technique that web application vulnerability
                  scanners use. Many people will focus their search on
                  cgi's for example or server specific issues such as
                  IIS problems. Many tools install "sample" code in
                  publicly accessible locations, which may have
                  security vulnerabilities. Removing (or simply not
                  installing) such default files is a critical step in
                  securing a web site.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Unreferenced Files - Many web site administrators
                  leave files on the web server such as admin pages or
                  data files that are not publicly available. These
                  files remain accessible although are unreferenced by
                  any HTML pages on the web site. If an attacker can
                  guess the URL, then he is typically able to access
                  the resource.  This may be accomplished because of
                  insider information or because the unreferenced
                  files have names that can be easily guessed.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Referenced Files - These files are files that are
                  referenced in the HTML pages returned by the
                  application, but where a hyperlink is not provided.
                  These files are often referenced in a comment or by
                  the use of a hidden form field.  These may include
                  configuration files, data files or templates.  Some
                  developers do not realize that using the "src"
                  attribute of the script tag and placing the script
                  code in a file on the server offers no protection
                  from an attacker.  The file can simply be requested
                  from the server and downloaded.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Backup/Temp Files - Many applications used to build
                  or edit source code and other files such as HTML or
                  XML leave temp files and backup files in
                  directories. Some development teams even create
                  these files manually as part of their maintenance
                  process.  These files often get uploaded either
                  manually in directory copies or automatically by the
                  deployment process. When files are edited directly
                  on production servers, the backup files may be
                  created there and never deployed to the
                  server. Backup files are dangerous as the source
                  code for the application may be exposed.  While
                  pages such as ASP, JSP or Perl will normally be
                  executed and the results returned to the user, the
                  execution process is normally based on file
                  extension.  Since backup or temp files may not have
                  an extension, which is recognized as needing
                  execution privileges, the default behavior of the
                  web server is to return the page unchanged.  In the
                  case of source code, this may expose logins,
                  passwords, database connectivity information, hidden
                  or unreferenced files, etc.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Directory Browsing - Normally, a user accesses a web
                  application through the web pages that have been
                  exposed by the developers.  However, through
                  vulnerabilities in the web server misconfigurations
                  of the web server or other tools, the directory
                  listing where the application resides can be exposed
                  to an attacker.  This can expose unlinked files that
                  otherwise would be difficult to guess without inside
                  information. This takes out all of the guesswork
                  involved in forceful browsing.
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
			<sect3>
				<title>Mitigation Checklist</title>
				<itemizedlist mark="opencircle" spacing="compact">
					<listitem>
						<para>
                  Remove all unnecessary files from the web server.
                  This includes sample files, temp or backup files,
                  test code, etc.
                  </para>
					</listitem>
					<listitem>
						<para>
                  Modify your deployment process to only allow
                  approved files to be deployed to the production
                  servers
                  </para>
					</listitem>
					<listitem>
						<para>
                  Do not allow editing of files directly on the
                  production servers
                  </para>
					</listitem>
					<listitem>
						<para>
                  Modify the web server configuration to only allow
                  approved extensions to be returned by the web
                  server.  If only .asp, .jpg, .gif, .js, .css and
                  .html are a part of the application, don't allow
                  .bak, ~, .tmp and other common backup extensions to
                  be returned.
                  </para>
					</listitem>
					<listitem>
						<para>
                  For unreferenced files used by the web application,
                  do not place these files in the docroot of the web
                  server
                  </para>
					</listitem>
				</itemizedlist>
			</sect3>
		</sect2>
	</sect1>
	<sect1>
		<title>Summary</title>
		<para>
      This chapter covered the common application security issues
      revolving around:
      </para>
		<itemizedlist mark="opencircle" spacing="compact">
			<listitem>
				<para>
            the use of tools
            </para>
			</listitem>
			<listitem>
				<para>
            disclosure of sensitive information
            </para>
			</listitem>
			<listitem>
				<para>
            unintended file access
            </para>
			</listitem>
		</itemizedlist>
		<para>
      While dealing with these issues will not secure an application
      on their own, these problems are commonly found in most
      applications.  Focus on these issues is a necessary component in
      securing an application.
      </para>
	</sect1>
</chapter>
